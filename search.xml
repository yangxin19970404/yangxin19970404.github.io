<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>博客用域名访问</title>
      <link href="/2019/10/14/2019-10-14-%E5%9F%9F%E5%90%8D/"/>
      <url>/2019/10/14/2019-10-14-%E5%9F%9F%E5%90%8D/</url>
      
        <content type="html"><![CDATA[<h1 id="关于如何用域名访问自己的博客"><a href="#关于如何用域名访问自己的博客" class="headerlink" title="关于如何用域名访问自己的博客"></a>关于如何用域名访问自己的博客</h1><hr><ol><li>购买域名自行选择阿里，百度云等，不同类型的域名有不同的费用，自行购买即可。我之前买的是百度云的.top 域名，很便宜，一年才9块钱好像。购买完以后开始域名解析，在管理控制台中。<br><img src="https://img-blog.csdnimg.cn/2019071011575964.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNTQwOTg5,size_16,color_FFFFFF,t_70" alt> </li><li>我们需要建立两个域名解析条例<br><img src="https://img-blog.csdn.net/20180617203033955?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RyMTkxMg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt></li><li>解析A类型：记录值是 你打开cmd  ping  一下你的  （例如：<br>(yangxin19970404.github.io) 就可以得到。也可以直接解析到 (bailijie.github.io)例如CNAME类型。<br><img src="https://img-blog.csdnimg.cn/20190710120158114.png" alt> </li></ol><ol start="4"><li><p>在Hexo目录下的source中建一个CNAME命名的文件夹(切记没有后缀)创建方式：新建txt文本→输入你购买的域名<a href="http://www.blj0105.top→保存即可然后右键该txt文本重命名→将.txt后缀去掉→会提示文件不可用继续确定即可" target="_blank" rel="noopener">www.blj0105.top→保存即可然后右键该txt文本重命名→将.txt后缀去掉→会提示文件不可用继续确定即可</a><br><img src="https://img-blog.csdnimg.cn/20190710120629664.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNTQwOTg5,size_16,color_FFFFFF,t_70" alt> </p><ol start="5"><li>绑定域名：进入github 项目中，点击setting，进入setting页面后，往下找，改成你购买的域名。<br><img src="https://img-blog.csdnimg.cn/20190710140627795.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNTQwOTg5,size_16,color_FFFFFF,t_70" alt> </li></ol><h2 id="不要质疑我-你已经成功了"><a href="#不要质疑我-你已经成功了" class="headerlink" title="不要质疑我,你已经成功了!!!!"></a>不要质疑我,你已经成功了!!!!</h2></li></ol>]]></content>
      
      
      <categories>
          
          <category> 服务器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 域名 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于Tomcat乱码</title>
      <link href="/2019/10/14/2019-10-14-tomcat%E4%B9%B1%E7%A0%81/"/>
      <url>/2019/10/14/2019-10-14-tomcat%E4%B9%B1%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<h1 id="关于Tomcat在Idea中文乱码问题"><a href="#关于Tomcat在Idea中文乱码问题" class="headerlink" title="关于Tomcat在Idea中文乱码问题"></a>关于Tomcat在Idea中文乱码问题</h1><hr><p><strong>问题，在idea中出现乱码问题，以前没有的，好像在设置系统代码为utf8之后就出现了，于是尝试了一系列办法，希望这些办法对大家有帮助。先看一下乱码的样式。</strong></p><p><img src="https://img2018.cnblogs.com/blog/717943/201901/717943-20190124093506839-714069128.png" alt> </p><h4 id="设置方法"><a href="#设置方法" class="headerlink" title="设置方法"></a>设置方法</h4><ol><li>在tomcat Server中设置 VM options , 值为 -Dfile.encoding=UTF-8 ，可惜没生效<br><img src="https://img2018.cnblogs.com/blog/717943/201901/717943-20190124093658943-1191924990.png" alt> </li><li>在setting中的 File encodings 中设置编码格式，后来发现这是设置页面编码格式的，所以也没生效，不过遇到相关问题的朋友也不防照此设置下。<br><img src="https://img2018.cnblogs.com/blog/717943/201901/717943-20190124094119079-1885159073.png" alt> </li><li>在java Complier中设置Additional command line parameters的值，-encoding=UTF-8，很可惜还没生效<br><img src="https://img2018.cnblogs.com/blog/717943/201901/717943-20190124094405855-2002294699.png" alt> </li><li>在bin中设置idea.exe.vmoptions和idea64.exe.vmoptions中的参数，同时增加-Dfile.encoding=UTF-8，据说有些人保存后重启就可以了，但到我这边还是没生效。<br><img src="https://img2018.cnblogs.com/blog/717943/201901/717943-20190124094613937-68757272.png" alt> </li><li>在tomcat \bin目录下的catalina.bat文件中加入 -Dfile.encoding=UTF-8，可是还不生效，有些抓狂了…<br><img src="https://img2018.cnblogs.com/blog/717943/201901/717943-20190124094827745-504540766.png" alt> </li><li>在 tomcat / conf 目录下，设置 logging.properties ，增加参数  java.util.logging.ConsoleHandler.encoding = GBK，重启后终于可以了，总算松了口气。<br><img src="https://img2018.cnblogs.com/blog/717943/201901/717943-20190124094951059-25415614.png" alt>  <h3 id="终于，正常显示了……"><a href="#终于，正常显示了……" class="headerlink" title="终于，正常显示了……"></a>终于，正常显示了……</h3><img src="https://img2018.cnblogs.com/blog/717943/201901/717943-20190124095057327-1632560035.png" alt></li></ol>]]></content>
      
      
      <categories>
          
          <category> Tomcat </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tomcat </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于MongoDB下载速度慢</title>
      <link href="/2019/10/12/2019-10-12-mongodb/"/>
      <url>/2019/10/12/2019-10-12-mongodb/</url>
      
        <content type="html"><![CDATA[<h1 id="关于Windows下载MongoDB速度特别慢的解决办法"><a href="#关于Windows下载MongoDB速度特别慢的解决办法" class="headerlink" title="关于Windows下载MongoDB速度特别慢的解决办法"></a>关于Windows下载MongoDB速度特别慢的解决办法</h1><hr><p><a href="https://www.mongodb.com/download-center/community" target="_blank" rel="noopener">MongoDB下载地址</a></p><p><img src="https://img-blog.csdnimg.cn/20190422155040994.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMzNDMwMDgz,size_16,color_FFFFFF,t_70" alt></p><hr><h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><p><strong>1.使用cmd命令ping dl.mongodb.org得到ip地址。</strong><br><img src="https://img-blog.csdnimg.cn/20190422155122433.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMzNDMwMDgz,size_16,color_FFFFFF,t_70" alt></p><p><strong>2.修改C:\Windows\System32\drivers\etc\ 下hosts文件在末尾加上 52.206.222.245 dl.mongodb.org。重新打开浏览器下载。</strong>  这里必须将浏览器关闭重新才会生效<br>配置中的ip要根据自己ping到的是什么就填什么<br><img src="https://img-blog.csdnimg.cn/20190422155401376.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMzNDMwMDgz,size_16,color_FFFFFF,t_70" alt> </p><p><strong>3.再进行下载查看速度会有明显变化</strong><br><img src="https://img-blog.csdnimg.cn/20190422155505874.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMzNDMwMDgz,size_16,color_FFFFFF,t_70" alt>  </p>]]></content>
      
      
      
        <tags>
            
            <tag> MOngoDB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>建国70周年</title>
      <link href="/2019/10/08/2019-09-24-qq/"/>
      <url>/2019/10/08/2019-09-24-qq/</url>
      
        <content type="html"><![CDATA[<h1 id="关于建国70周年"><a href="#关于建国70周年" class="headerlink" title="关于建国70周年!!"></a>关于建国70周年!!</h1><p><strong>这是一个黑暗的时代，这是一个愚昧落后的时代，这是一个充满压迫与专制的腐朽年代。然而，一句“中华人民共和国中央人民政府今天成立了!”如惊雷般响彻大地，打破沉寂;如利剑般划破长空，驰骋苍穹;如潮水般乘风破浪，直挂云帆。黎明从这里开始，黑暗在这里埋葬，历史在这里载入新的一页。这声音如婴儿的第一声啼哭，是生的声音，是希望的声音，是倔强不低头的声音。这声音饱含母亲的剧痛与爱心。多少仁人志士为了这一”生之音“的到来曾鞠躬尽瘁，死而后已啊!不能忘记，泸定桥上为夺取胜利与敌人浴血奋战的英雄;不能忘记，狼牙山上为不当俘虏视死如归的壮士;不能忘记，长江天堑上为最后的胜利英勇无畏的忠魂。一个世纪的屈辱随着这声巨响，销声匿迹。富之音当”春天的故事“演绎成一个民族富裕的神话。没有谁会怀疑”改革开放“声音的穿透力和震撼力。这声音像春雨洒向神州大地的每一个角落。从伊利草原到南沙群岛，从帕米尔高原到泰山之颠。改革在这里扎根，开放在这里欢唱，改革开放奏响时代最强音。当世界7%的土地成功养活世界上22%的人口时;当香港、澳门如约回到祖国的怀抱时;当唐古拉山传来隆隆的汽笛声时。一个国家一个民族正像世界传递着富裕的声音。美国的自由女神听到了，巴黎的埃菲尔铁塔注视到了，英国的白金汉宫感受到了。声音如此响亮，乐章如此高亢，感情如此激昂!正如改革开放的窗口由一个小渔村发展为一个大都市，神州大地正发生着自盘古开天辟地以来最深刻的变化。地王大厦是深圳崛起的标志，而改革开放无疑是中华民族伟大复兴的开端。风雨彩虹，霜浓叶红。一个老人的声音改变一个民族的面貌。富裕的声音遍递华夏，传向世界，遍至宇宙!百年梦想，圆梦今朝。世界给中国一次机会，而中国向世界人民呈上一份完美的答卷。奥运会是一个窗口，是一次契机，是一组信号。中国向世界传递出她日益强大的声音!如果说奥运会是一股东风，那么中国这艘巨船正借着东风驶入世界的河流。凤凰在烈火中涅盘，雄狮沉睡中苏醒!甲子轮回苦与笑，共和国兴民兴业谱就旷世乐章一首气势恢弘的壮丽乐章在神州大地回荡。这乐章如此动人，如此扣人心弦，听之让人心潮澎湃!聆听共和国之音，追寻她不平凡的成长足迹;聆听共和国之音，见证她波澜壮阔的奇迹;聆听共和国之音，期待她更辉煌的业绩!</strong></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>阶段感悟</title>
      <link href="/2019/10/08/2019-09-19-%E6%97%A5%E6%8A%A5/"/>
      <url>/2019/10/08/2019-09-19-%E6%97%A5%E6%8A%A5/</url>
      
        <content type="html"><![CDATA[<h2 id="关于-兄弟会"><a href="#关于-兄弟会" class="headerlink" title="关于 兄弟会"></a>关于 兄弟会</h2><hr><p><strong>来兄弟会已经一个多月了,在这里遇到了优秀的教练,遇到了可爱的同事,同时也学到了不少东西.在这期间,被教练安排过,那可真是难忘的经历,大家都是抱着远大理想努力往这个班级进,所以大家都很努力的学习.有的时候难到想过放弃,但是最后都坚持下来了,没有什么事是过不去的.来这里之后,兄弟会也在不断地改善,不断的完善制度,整挺好!从刚开始的不知如何下手到现在慢慢体会到敲代码的乐趣也是一种进步吧!!!刚开始真的会觉得它是一个很死板很费脑的东西,不过这一个月里我发现它的乐趣真的是无穷的,就当你自己写一段代码能够运行得到你想要的结果的时候,心里会有一种小小的成就感,这种成就感就能驱使你去学更多更难的东西,这个过程也是一个积累和不断开拓的过程,希望每天的成就感能督促我快点加油变成大佬,毕竟每天都做着能成为大佬的梦</strong></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Vue-cli安装</title>
      <link href="/2019/10/08/2019-09-17-vue/"/>
      <url>/2019/10/08/2019-09-17-vue/</url>
      
        <content type="html"><![CDATA[<h2 id="关于安装vue-cli失败"><a href="#关于安装vue-cli失败" class="headerlink" title="关于安装vue-cli失败"></a>关于安装vue-cli失败</h2><hr><h3 id="显示未找到命令-原因是缺少软连接-解决方法如下"><a href="#显示未找到命令-原因是缺少软连接-解决方法如下" class="headerlink" title="显示未找到命令,原因是缺少软连接,解决方法如下:"></a>显示未找到命令,原因是缺少软连接,解决方法如下:</h3><p><img src="/image/%E6%B7%B1%E5%BA%A6%E6%88%AA%E5%9B%BE_%E9%80%89%E6%8B%A9%E5%8C%BA%E5%9F%9F_20190917162353.png" alt></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>第二十六天</title>
      <link href="/2019/10/08/2019-09-09-tu/"/>
      <url>/2019/10/08/2019-09-09-tu/</url>
      
        <content type="html"><![CDATA[<h2 id="第二十六天"><a href="#第二十六天" class="headerlink" title="第二十六天"></a>第二十六天</h2><hr><p><strong>兄弟会JS部分小成果</strong><a href="victor981221.github.io"></a>  </p><p><img src="/image/21.jpg" alt></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>PS 2017安装</title>
      <link href="/2019/10/08/2019-09-08-PS2017%E5%AE%89%E8%A3%85/"/>
      <url>/2019/10/08/2019-09-08-PS2017%E5%AE%89%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<h2 id="PS安装"><a href="#PS安装" class="headerlink" title="PS安装"></a>PS安装</h2><hr><h3 id="安装前提是深度系统啊"><a href="#安装前提是深度系统啊" class="headerlink" title="安装前提是深度系统啊"></a>安装前提是深度系统啊</h3><p> <strong>这是安装包，都放在一起了，直接下载就好了！！有时候会有bug，体谅一哈。</strong>链接: <a href="https://pan.baidu.com/s/1-T9JKwSlUXFAUDMGRioyzg" target="_blank" rel="noopener">https://pan.baidu.com/s/1-T9JKwSlUXFAUDMGRioyzg</a>  密码: 6d0p  </p><h2 id="这是效果图"><a href="#这是效果图" class="headerlink" title="这是效果图"></a>这是效果图</h2><p><img src="/image/ps.png" alt></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>第二十三天啦</title>
      <link href="/2019/10/08/2019-09-06-23/"/>
      <url>/2019/10/08/2019-09-06-23/</url>
      
        <content type="html"><![CDATA[<h2 id="第二十三天啦"><a href="#第二十三天啦" class="headerlink" title="第二十三天啦"></a>第二十三天啦</h2><hr><h2 id="Ubuntu环境下载最新版本的nodejs和npm"><a href="#Ubuntu环境下载最新版本的nodejs和npm" class="headerlink" title="Ubuntu环境下载最新版本的nodejs和npm"></a>Ubuntu环境下载最新版本的nodejs和npm</h2><p>nodejs版本是：v10.11.0 npm版本是：6.4.1 教程如下：</p><h3 id="一-下载最新版本的nodejs包-最新版本的nodejs包里默认含有npm"><a href="#一-下载最新版本的nodejs包-最新版本的nodejs包里默认含有npm" class="headerlink" title="一.下载最新版本的nodejs包(最新版本的nodejs包里默认含有npm)"></a>一.下载最新版本的nodejs包(最新版本的nodejs包里默认含有npm)</h3><p>先去nodejs官网去查看最新的nodejs <a href="https://nodejs.org/en/download/current/" target="_blank" rel="noopener">Nodejs官网:</a> 使用版本: v10.11.0</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">wget https://nodejs.org/dist/v10.11.0/node</span><br><span class="line">-v10.11.0-linux-x64.tar.xz    </span><br><span class="line"></span><br><span class="line">tar xf  node-v10.11.0-linux-x64.tar.xz     // 解压</span><br><span class="line"></span><br><span class="line">cd node-v10.11.0-linux-x64/                // 进入解压目录</span><br><span class="line"></span><br><span class="line">node -v                                    // 执行node命令 </span><br><span class="line">                                              查看版本</span><br></pre></td></tr></table></figure><p>下载到你的当前的目录,例: /home/root/ </p><p>注意:创建软链接的时候要写<strong>绝对路径</strong>, 软链接到/usr/local/bin/ 在创建软链接时,需赋予 node,npm 权限</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ sudo ln -s /home/nineberg/node-v10.11.0-linux</span><br><span class="line">-x64/bin/node /usr/local/bin/</span><br><span class="line"></span><br><span class="line">$ sudo ln -s /home/nineberg/node-v10.11.0-linux</span><br><span class="line">-x64/bin/npm /usr/local/bin/</span><br></pre></td></tr></table></figure><p><strong>注意:!!!!这是如果你在创建软连的时候，出现npm已经存在,node 已经存在, 没有则跳过</strong> 解决方案： 删除 /usr/lo/bin/目录下的node，npm</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo rm -rf /usr/local/bin/node</span><br><span class="line">$ sudo rm -rf /usr/local/bin/npm</span><br></pre></td></tr></table></figure><p>之后再创建软链接</p><h3 id="检查"><a href="#检查" class="headerlink" title="检查"></a>检查</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ node -v</span><br><span class="line"></span><br><span class="line">$ npm -v</span><br></pre></td></tr></table></figure><p>显示出版本则安装成功</p><p># </p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>第二十二天啦</title>
      <link href="/2019/10/08/2019-09-05-22/"/>
      <url>/2019/10/08/2019-09-05-22/</url>
      
        <content type="html"><![CDATA[<h2 id="第二十二天啦"><a href="#第二十二天啦" class="headerlink" title="第二十二天啦"></a>第二十二天啦</h2><hr><p><strong>今天可又是难忘的一天，今天是我最绝望的一天，之前的都是弟弟啊。体会到了什么叫××××，哎，没办法谁让我们没有完成任务呢，就该接受惩罚，其实航哥这段时间里就一直在打压我们，我心里也都明白，但是，有时我们也需要一些小小的鼓励啊，俗话说的好“没有压力就没有动力”但是还有一句话啊“成功的人都是鼓励出来的”其实有点为我们的不够努力在找借口，人啊就是这样，总是在为自己找借口，所以这样的人注定不能成功。这是我进兄弟会的原因，我想成为优秀的人。所以不管前方有多少艰难困苦，杨鑫你都不能放弃，你除了成功别无选择！！</strong></p><h1 id="吃得苦中苦，方能成为人上人！加油杨鑫！"><a href="#吃得苦中苦，方能成为人上人！加油杨鑫！" class="headerlink" title="吃得苦中苦，方能成为人上人！加油杨鑫！"></a>吃得苦中苦，方能成为人上人！加油杨鑫！</h1>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>第二十一天啦</title>
      <link href="/2019/10/08/2019-09-04-21/"/>
      <url>/2019/10/08/2019-09-04-21/</url>
      
        <content type="html"><![CDATA[<h2 id="第二十一天啦"><a href="#第二十一天啦" class="headerlink" title="第二十一天啦"></a>第二十一天啦</h2><hr><p><strong>今天可真是难忘的一天，白天都在复习，我也在准备周五的组分享，过得很平静，但是下午快结束的时候，航哥进来了，突然就要考试，而且考的使我们这几天没有接触到，所以我们有点麻爪，一直在手忙脚乱的弄着自己的作业，然而结果可想而知，没有一个人完成，时间到了，全军覆没。航哥使出了新招数，组员蹲着看组长做，直到完成为止，我们蹲了半个多小时，脚真是没有知觉了，但是我们看到了效果，我们所有人都完成了。然后吃饭的时候，我们也总结了今天的内容，航哥其实就是要我们团结在一起把任务完成，然而这都是我们事后才反应过来，真是涨了姿势！！！！</strong></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>第二十天啦</title>
      <link href="/2019/10/08/2019-09-03-20/"/>
      <url>/2019/10/08/2019-09-03-20/</url>
      
        <content type="html"><![CDATA[<h2 id="第二十天啦"><a href="#第二十天啦" class="headerlink" title="第二十天啦"></a>第二十天啦</h2><hr><h1 id="今天是将近崩溃的一天"><a href="#今天是将近崩溃的一天" class="headerlink" title="今天是将近崩溃的一天"></a>今天是将近崩溃的一天</h1><hr><p><strong>上午是很平常的，复习了一下聊天室的内容，因为马上就要阶段考试了， 不能拖后腿！中午的时候，航哥进来宣布了一个好消息，哈哈哈我们的新装备到了，我们班换了新的桌子和椅子，干了一下午的，又一次感受到大汗淋漓的感觉，很刺激，当然也很开心啊！5点半，终于把所有的桌子安装完成。我们换了新的环境，新的学习空间，心情也是很好的！然而我并不知道危险正向我一步步的靠近，晚自习的时候，我准备安装一下jdk，想要在周五的时候讲一下java的内容，然而，我要疯了，实在是太难了，安炸了，真是弄了一个晚上，接近崩溃！！！！！！但好在我没有放弃，静下心来，把他弄好了，这种成就感，我觉得是任何人都体会不到的，哈哈哈哈,放一张自拍，哈哈哈哈</strong>   </p><p><img src="/image/741.jpg" alt></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>事件与DOM</title>
      <link href="/2019/10/08/2019-09-02-%E4%BA%8B%E4%BB%B6%E4%B8%8EDOM/"/>
      <url>/2019/10/08/2019-09-02-%E4%BA%8B%E4%BB%B6%E4%B8%8EDOM/</url>
      
        <content type="html"><![CDATA[<h2 id="事件！！"><a href="#事件！！" class="headerlink" title="事件！！"></a>事件！！</h2><h4 id="事件的绑定与解除"><a href="#事件的绑定与解除" class="headerlink" title="事件的绑定与解除"></a>事件的绑定与解除</h4><p><strong>绑定：$(“选择器”).bind( “事件类型”，function(){} );</strong><br><strong>解除：$(“选择器”).unbind( “事件类型” );</strong>  </p><h4 id="常用的事件"><a href="#常用的事件" class="headerlink" title="常用的事件"></a>常用的事件</h4><table><thead><tr><th align="center">代码</th><th align="center">解释</th></tr></thead><tbody><tr><td align="center">click(fn)/click()</td><td align="center">单击</td></tr><tr><td align="center">dblclick(fn)/dblclick()</td><td align="center">双击</td></tr><tr><td align="center">blur(fn)/blur()</td><td align="center">失去焦点</td></tr><tr><td align="center">focus(fn)/focus()</td><td align="center">获得焦点</td></tr><tr><td align="center">change(fn)/change()</td><td align="center">改变值</td></tr><tr><td align="center">keydown(fn)/keydown()</td><td align="center">键盘 按下去</td></tr><tr><td align="center">keyup(fn)/keyup()</td><td align="center">键盘 弹上来</td></tr><tr><td align="center">mouseover(fn)/mouseover()</td><td align="center">鼠标 挪上来</td></tr><tr><td align="center">mouseout(fn)/mouseout()</td><td align="center">鼠标 离开了</td></tr><tr><td align="center">submit(fn)/submit()</td><td align="center">表单提交事件</td></tr><tr><td align="center">load(fn)/unload(fn)</td><td align="center">加载事件</td></tr></tbody></table><h4 id="组合事件函数"><a href="#组合事件函数" class="headerlink" title="组合事件函数"></a>组合事件函数</h4><p>   <strong>$(“选择器”).hover(1,2);</strong></p><ol><li><p>匿名函数（等同于 mouseover）  </p></li><li><p>匿名函数（等同于 mouseout）  </p></li></ol><h2 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h2><h4 id="创建节点"><a href="#创建节点" class="headerlink" title="创建节点"></a>创建节点</h4><pre><code>var newLi = $(&quot;&lt;li&gt;x&lt;/li&gt;&quot;);</code></pre><h4 id="添加节点"><a href="#添加节点" class="headerlink" title="添加节点"></a>添加节点</h4><table><thead><tr><th>append</th><th>//在ul里末尾追加li$(“ul”).append(newLi);</th></tr></thead><tbody><tr><td>prepend</td><td>//在ul里前置追加li$(“ul”).prepend(newLi);</td></tr><tr><td>after</td><td>//与ul平级的后面追加li$(“ul”).after(newLi);</td></tr><tr><td>before</td><td>//与ul平级的前面追加li$(“ul”).before(newLi);</td></tr></tbody></table><h4 id="删除节点"><a href="#删除节点" class="headerlink" title="删除节点"></a>删除节点</h4><table><thead><tr><th>$(“li:first”).remove();</th></tr></thead><tbody><tr><td>//清空元素内容$(“li:first”).empty();</td></tr></tbody></table><h4 id="复制节点"><a href="#复制节点" class="headerlink" title="复制节点"></a>复制节点</h4><table><thead><tr><th>//克隆第一个livar li = $(“li:first”).clone();//添加到最后一个li的后边$(“li:last”).after(li);</th></tr></thead><tbody><tr><td>//克隆第一个li（以及绑定的事件也克隆过来）var li = $(“li:first”).clone(true);$(“li:last”).after(li);</td></tr></tbody></table><h4 id="遍历节点"><a href="#遍历节点" class="headerlink" title="遍历节点"></a>遍历节点</h4><table><thead><tr><th>chiledren()</th><th>子代</th></tr></thead><tbody><tr><td>next()</td><td>后边紧邻的兄弟</td></tr><tr><td>prev()</td><td>前边紧邻的兄弟</td></tr><tr><td>siblings()</td><td>所有兄弟</td></tr><tr><td>find(选择器)</td><td>后代和子代</td></tr><tr><td>parent()</td><td>父级</td></tr><tr><td>parents(选择器)</td><td>祖先级</td></tr><tr><td>eq(下标)</td><td>第几个元素</td></tr><tr><td>first()</td><td>第一个</td></tr><tr><td>last()</td><td>最后一个</td></tr><tr><td>is(选择器)</td><td>是不是； is(“ul”):当前的元素是不是ul</td></tr><tr><td>not(选择器)</td><td>除了“选择器”之外的</td></tr><tr><td>get(下标)</td><td>转换函数：jQuery对象 —&gt;  js对象</td></tr></tbody></table><h4 id="手风琴导航效果"><a href="#手风琴导航效果" class="headerlink" title="手风琴导航效果"></a>手风琴导航效果</h4><p><img src="/image/4.png" alt></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">$(<span class="string">"dt"</span>).on(<span class="string">"click"</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="comment">// 所有dd，除了点击的dt的兄弟dd， 隐藏</span></span><br><span class="line">$(<span class="string">"dd"</span>).not( $(<span class="keyword">this</span>).siblings() ).slideUp(<span class="string">'slow'</span>);</span><br><span class="line">      <span class="comment">// 点击的dt的兄弟，切换显示（显示的隐藏，隐藏的显示）</span></span><br><span class="line">$(<span class="keyword">this</span>).siblings().slideToggle(); <span class="comment">//fast</span></span><br><span class="line">&#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>jQuery选择器</title>
      <link href="/2019/10/08/2019-09-02-jquery/"/>
      <url>/2019/10/08/2019-09-02-jquery/</url>
      
        <content type="html"><![CDATA[<h2 id="JQuery强大的选择器"><a href="#JQuery强大的选择器" class="headerlink" title="JQuery强大的选择器"></a>JQuery强大的选择器</h2><hr><h4 id="基本选择器"><a href="#基本选择器" class="headerlink" title="基本选择器"></a><strong>基本选择器</strong></h4><table><thead><tr><th align="center">标签选择器</th><th>$(“p”).css(“color”,”red”);</th></tr></thead><tbody><tr><td align="center">id选择器</td><td>$(“#er”).css(“color”,”red”);</td></tr><tr><td align="center">class选择器</td><td>$(“.si”).css(“color”,”red”);</td></tr><tr><td align="center">选择器1，选择器2。。。</td><td>$(“#er,.si”).css(“color”,”red”);</td></tr></tbody></table><h4 id="层级选择器"><a href="#层级选择器" class="headerlink" title="层级选择器"></a><strong>层级选择器</strong></h4><table><thead><tr><th align="center">后代选择器</th><th>$(“#d2 p”).css(“color”,”red”);  p1p2</th></tr></thead><tbody><tr><td align="center">子代选择器</td><td>$(“#d2&gt;p”).css(“color”,”red”);  p1</td></tr><tr><td align="center">相邻的兄弟</td><td>$(“#d2+p”).css(“color”,”red”);</td></tr><tr><td align="center">后面的所有兄弟</td><td>$(“#d2~p”).css(“color”,”red”);</td></tr></tbody></table><h4 id="基本的筛选选择器"><a href="#基本的筛选选择器" class="headerlink" title="基本的筛选选择器"></a><strong>基本的筛选选择器</strong></h4><table><thead><tr><th align="center">第一个元素</th><th>$(“p:first”).css(“color”,”red”);</th></tr></thead><tbody><tr><td align="center">最后一个元素</td><td>$(“p:last”).css(“color”,”red”);</td></tr><tr><td align="center">not过滤</td><td>$(“p:not(.si)”).css(“color”,”red”);</td></tr><tr><td align="center">下标为奇数的元素</td><td>$(“p:odd”).css(“color”,”red”);</td></tr><tr><td align="center">下标为偶数的元素</td><td>$(“p:even”).css(“color”,”red”);</td></tr><tr><td align="center">下标相等的</td><td>$(“p:eq(2)”).css(“color”,”red”);</td></tr><tr><td align="center">大于下标的</td><td>$(“p:gt(2)”).css(“color”,”red”);</td></tr><tr><td align="center">小于小标的</td><td>$(“p:lt(2)”).css(“color”,”red”);</td></tr></tbody></table><h4 id="表单选择器"><a href="#表单选择器" class="headerlink" title="表单选择器"></a><strong>表单选择器</strong></h4><table><thead><tr><th align="center">:input</th><th>选取所有输入框</th></tr></thead><tbody><tr><td align="center">:text</td><td>选取所有的文本框</td></tr><tr><td align="center">: password</td><td>选取所有的密码框</td></tr><tr><td align="center">: radio</td><td>选取所有的单选按钮</td></tr><tr><td align="center">: checkbox</td><td>选取所有的复选框</td></tr><tr><td align="center">: submit</td><td>选取所有的提交按钮</td></tr><tr><td align="center">: reset</td><td>选取所有的重置按钮</td></tr><tr><td align="center">: button</td><td>选取所有的按钮</td></tr><tr><td align="center">: file</td><td>选取所有的文件域</td></tr><tr><td align="center">: hidden</td><td>选取所有的隐藏域</td></tr></tbody></table><p><img src="/image/1.png" alt></p><h2 id="属性函数，样式函数"><a href="#属性函数，样式函数" class="headerlink" title="属性函数，样式函数"></a>属性函数，样式函数</h2><table><thead><tr><th align="center">$(“img”).attr(“title”);</th><th><strong>得到</strong>img的title属性值</th></tr></thead><tbody><tr><td align="center">$(“img”).attr(“title”,”xxx”);</td><td><strong>设置</strong>img的title属性值</td></tr><tr><td align="center">$(“img”).removeAttr(“title”);</td><td><strong>移除</strong>img的title属性值</td></tr></tbody></table><table><thead><tr><th align="center">$(“input”).val();</th><th><strong>得到</strong>input框的值</th></tr></thead><tbody><tr><td align="center">$(“input”).val(“xxxx”);</td><td><strong>设置</strong>input框的值</td></tr></tbody></table><table><thead><tr><th align="center">$(“div”).text();</th><th><strong>得到</strong>div里面的纯文本内容</th></tr></thead><tbody><tr><td align="center">$(“div”).text(“xxxx”);</td><td><strong>设置</strong>div里面的纯文本内容</td></tr></tbody></table><table><thead><tr><th align="center">$(“div”).html();</th><th><strong>得到</strong>div里面所有内容（html标签+文本值）</th></tr></thead><tbody><tr><td align="center">$(“div”).html(“xxxx”);</td><td><strong>设置</strong>div里面所有内容（html标签+文本值）</td></tr></tbody></table><p><img src="/image/2.png" alt></p><h2 id="样式函数"><a href="#样式函数" class="headerlink" title="样式函数"></a>样式函数</h2><p><img src="/image/3.png" alt></p><table><thead><tr><th align="center">$(“p”).addClass(“fan”);</th><th>为元素添加类样式</th></tr></thead><tbody><tr><td align="center">$(“p”).removeClass(“fan”);</td><td>为元素移除类样式</td></tr><tr><td align="center">$(“p”).<strong>toggleClass</strong>(“fan”);</td><td>切换样式（有-&gt;无、无-&gt;有）</td></tr></tbody></table><table><thead><tr><th align="center">$(“p”).css(“css属性”)</th><th><strong>获得</strong>p元素的css属性的值</th></tr></thead><tbody><tr><td align="center">$(“p”).css(“属性”,”值”)</td><td><strong>设置</strong>p元素的css属性的值</td></tr><tr><td align="center">$(“p”).css({json})</td><td><strong>设置</strong>p元素多个css属性的值</td></tr><tr><td align="center">$(“p”).css({“width”:”150px”,”font-weight”:”bold”,”color”:”red”});</td><td></td></tr></tbody></table><table><thead><tr><th align="center">$(“div”).width()</th><th><strong>获得</strong>元素的宽度</th></tr></thead><tbody><tr><td align="center">$(“div”).height()</td><td><strong>获得</strong>元素的高度</td></tr><tr><td align="center">$(“div”).width(值)</td><td><strong>设置</strong>元素的宽度</td></tr><tr><td align="center">$(“div”).height(值)</td><td><strong>设置</strong>元素的高度</td></tr></tbody></table><p>div元素的宽度</p><table><thead><tr><th align="center">$(“div”).innerWidth()</th><th>包含内边距</th></tr></thead><tbody><tr><td align="center">$(“div”).outerWidth()</td><td>包含内边距+边框</td></tr><tr><td align="center">$(“div”).outerWidth(true)</td><td>包含内边距+边框+外边距</td></tr></tbody></table>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>第十九天</title>
      <link href="/2019/10/08/2019-09-02-19/"/>
      <url>/2019/10/08/2019-09-02-19/</url>
      
        <content type="html"><![CDATA[<h2 id="第十九天啦"><a href="#第十九天啦" class="headerlink" title="第十九天啦"></a>第十九天啦</h2><hr><h4 id="很充实的一天"><a href="#很充实的一天" class="headerlink" title="很充实的一天"></a>很充实的一天</h4><p><strong>今天买了个服务器，然后把前两天写的聊天系统推进了我的服务器，其实，我一直想有一个自己的服务器，想存一些自己的小东西，今天终于把他弄明白了，很开心。我的聊天系统的地址是  39.105.46.187:2000  可以一起聊天了，哈哈哈</strong></p><h4 id="晚上读书会"><a href="#晚上读书会" class="headerlink" title="晚上读书会"></a>晚上读书会</h4><h5 id="今晚听的书是《信息简史》"><a href="#今晚听的书是《信息简史》" class="headerlink" title="今晚听的书是《信息简史》"></a>今晚听的书是《信息简史》</h5><p>总结了一下，一共四个方面<br>一、信息是人对世界认知的碎片化呈现</p><p>所谓“碎片化“并不是现在才有的，而是伴随着信息产生的始终。信息的本质是人对世界认知的碎片化呈现。</p><p>信息之所以是碎片化的根本原因在于：人的认知结构就是碎片化的。现代心理学指出：人从婴儿时期，对外部世界的感知就是一步一步渐进的。随着生理和心理的成熟，才慢慢形成系统化。</p><p>虽然思维的逻辑化、结构化，让知识更好地传承，但这些并不是信息本身。人只是碎片化信息的载体。</p><p>人类在历史上，关于任何学科的每一本著作，和茫茫的宇宙比起来，都只是一个碎片。即便那些看起来好像概括了所有学科的“通识性”见解，也都只是从某一个角度解读这个世界。所以，信息的本质就是：人对世界认知的碎片化呈现。</p><p>二、信息维系着人类文明的完整性</p><p>人类社会是各种信息的总和，缺少了任何一种信息都是不完整的。在人类文明发展的过程当中，采取了图像、声音、文字等方式记录信息，借助这些信息，人才得以还原历史。整个人类社会才得以完整保存。</p><p>在人类文明漫长的演变进程当中，文字作为信息的载体之一，发挥了很大作用。早期诗歌之所以格律、程式化都非常强，就是因为朗朗上口的特征，能让人更好的记忆，便于口口相传。文字产生以后，象征信息已经可以不再依附于上一代的口头教导，能够隔代传承。</p><p>三、信息不仅被动记录世界，并且主动创造世界。</p><p>信息促进了人脑思维的产生，让知识结构化，并形成新知识的基础。从早期的差分机，到后来的电子计算机；从最初的电磁感应到后来的互联网，在这些一层层累加的基础上，人类社会不断产生新的创造，信息推进了人类文明的进步。</p><p>文字的产生，意味着书面文化“侵入”口语文化。这让人们形成了全新的思维方式，造成了不可逆转的后果。之前的创作，格律只是为了更好的记忆，然后口口相传。但文字的产生以后，让仅仅借助于人脑的记忆不再是必须的。如果忘了，翻一翻之前怎么写的就行了。诗歌的格律性，就慢慢脱离开单纯的记忆功能，向美感转变了。</p><p>信息在记录世界的同时，还让人把这个世界已有的知识加以结构化，从而总结出“关于知识的知识”。然后这些“关于知识的知识”，就像盖楼房一样，再层层累加不断推演出新的信息，创造新的世界。最终，让人类文明不断往前推进。</p><p>四、怎样消除信息过载的负面影响</p><p>人的记忆和信息处理的能力是有限的。在互联网快速发展的今天，人接收到的信息不仅远远大于人能够处理的信息，也远远大于人实际需要的信息。</p><p>信息过载使获取高质量、有价值的信息成本越来越高，也给人的身心健康带来负面影响。这时候，要从自身出发，正确收集和处理信息，运用好搜索和过滤工具，对海量信息进行筛选甄别。同时，要明确自身需求，内外兼修增强信息选择能力。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>第十八天啦</title>
      <link href="/2019/10/08/2019-08-31-18/"/>
      <url>/2019/10/08/2019-08-31-18/</url>
      
        <content type="html"><![CDATA[<h2 id="第十八天啦"><a href="#第十八天啦" class="headerlink" title="第十八天啦"></a>第十八天啦</h2><hr><p><strong>今天可以说是进入到 兄弟会最难忘的一天吧，可以说受到了第一次体罚，其实我已经猜到了结果，但是没想到航哥会生那么大的气，确实航哥对我们的期望高，我们让他失望了，我们做的不好，我们用着最好的资源，应该做最好的榜样，共同进步，不要落下每一个人，在规定的时间一起毕业，在学习方面，每一个阶段完成这个阶段的任务，这种模式是历届兄弟会传承下来的</strong></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>第十七天啦</title>
      <link href="/2019/10/08/2019-08-30-seven/"/>
      <url>/2019/10/08/2019-08-30-seven/</url>
      
        <content type="html"><![CDATA[<h2 id="第十七天啦"><a href="#第十七天啦" class="headerlink" title="第十七天啦"></a>第十七天啦</h2><hr><p><strong>今天接触了一个新知识，node.js   然后在这个基础上学会了搭建服务器，利用Socket.io模板做了一个简单的聊天室，接着又要给他化个妆，利用css和js部分内容，给这个聊天室进行了一个完善，下面就是我做的一个聊天室样式图</strong>   </p><hr><p><img src="/image/123.png" alt="123"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>第十六天啦</title>
      <link href="/2019/10/08/2019-08-29-sixteen/"/>
      <url>/2019/10/08/2019-08-29-sixteen/</url>
      
        <content type="html"><![CDATA[<h2 id="第十六天啦"><a href="#第十六天啦" class="headerlink" title="第十六天啦"></a>第十六天啦</h2><hr><h3 id="今天可就太充实了！"><a href="#今天可就太充实了！" class="headerlink" title="今天可就太充实了！"></a>今天可就太充实了！</h3><p><strong>今天从到教室开始，就一直在做js特效，没闲着啊，虽然有点累，但是很开心，这才是<br>我想要看到的学习氛围和学习方式。</strong>  </p><hr><p>有几个重要的知识点：  </p><p>var d = new Date();  </p><p>​            var timeStr =    d.getFullYear()+”-“+   (d.getMonth()+1)+”-“    +d.getDate()+”  “  +d.getHours()+”:”+d.getMinutes()+”:”+d.getSeconds();</p><p>​            document.getElementById(“title”).innerHTML = timeStr;   </p><p><strong>关于平铺</strong><br>background-repeat:repeat-x;<br>这个是横向平铺<br>background-repeat:repeat-y;<br>纵向平铺  </p><p><strong>晚自习开始，我想换个模板，结果，弄了3个小时，好吧我放弃了，我太难了！！！</strong></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>JS</title>
      <link href="/2019/10/08/2019-08-28-JS/"/>
      <url>/2019/10/08/2019-08-28-JS/</url>
      
        <content type="html"><![CDATA[<h2 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h2><hr><h3 id="周期性定时器"><a href="#周期性定时器" class="headerlink" title="周期性定时器"></a>周期性定时器</h3><ol><li>定时器 setInterval（1，2）：周期性定时器<br>1：重复执行的动作（函数）<br>2：时间间隔（毫秒）</li><li>停止定时任务 clearInterval（定时器对象）</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="keyword">var</span>   arr    =   [<span class="string">"img/1.jpg"</span>,<span class="string">"img/2.jpg"</span>,<span class="string">"img/3.jpg"</span>];</span><br><span class="line">   <span class="function"><span class="keyword">function</span>   <span class="title">bian</span>  (<span class="params"></span>)</span>&#123;</span><br><span class="line">          <span class="keyword">var</span>    tou  =   <span class="built_in">document</span>.getElementById(<span class="string">"tou"</span>);</span><br><span class="line">       tou.setAttribute(<span class="string">"src"</span>,arr[<span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random()*arr.length)]);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">var</span>   ob  =  setInterval(bian , <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">function</span>   <span class="title">stop</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">       clearInterval( ob );</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">function</span>   <span class="title">start</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">       ob  =  setInterval(bian , <span class="number">100</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">&lt;body&gt;</span></span><br><span class="line"><span class="regexp">        &lt;img  src = ""   id="tou"&gt;</span></span><br><span class="line"><span class="regexp">        &lt;button  onclick="stop()"&gt; 停止 &lt;/</span> button &gt;</span><br><span class="line">        &lt;button  onclick=<span class="string">"start()"</span>&gt; 启动 &lt;<span class="regexp">/ button &gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>body&gt;</span><br></pre></td></tr></table></figure><h3 id="一次性定时器"><a href="#一次性定时器" class="headerlink" title="一次性定时器"></a>一次性定时器</h3><ol><li><p>setTimeout（1，2）：只执行一次（类似延迟的效果）</p></li><li><p>执行的函数</p></li><li><p>间隔（毫秒单位）  </p></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">       <span class="function"><span class="keyword">function</span>   <span class="title">test</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                    <span class="built_in">document</span>.body.style.backgroundColor   =  <span class="string">"red"</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       setTimeout(test ,<span class="number">2000</span>);</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><hr><h3 id="每个文档都是一个document对象"><a href="#每个文档都是一个document对象" class="headerlink" title="每个文档都是一个document对象"></a>每个文档都是一个document对象</h3><h2 id="document-getElementById（id值"><a href="#document-getElementById（id值" class="headerlink" title="document.getElementById（id值)"></a>document.getElementById（id值)</h2><p>通过id值，获得唯一对象的  </p><p>示例：登录验证   </p><h2 id="document-getElementsByName-name值"><a href="#document-getElementsByName-name值" class="headerlink" title="document.getElementsByName( name值 )"></a>document.getElementsByName( name值 )</h2><p>通过name属性值，获得多个匹配的对象  </p><p>示例：全选/反选  </p><h2 id="document-getElementsByTagName-标签名"><a href="#document-getElementsByTagName-标签名" class="headerlink" title="document.getElementsByTagName(标签名)"></a>document.getElementsByTagName(标签名)</h2><p>通过标签名，获得多个匹配对象  </p><p>示例：隔行变色  </p><hr><h3 id="弹出框"><a href="#弹出框" class="headerlink" title="弹出框"></a>弹出框</h3><ol><li>alert（提示文字）：提示框  </li><li>confirm（提示文字）：确认框  </li><li>prompt（提示文字，默认值）：输入框    </li></ol><hr><h3 id="修改节点的样式"><a href="#修改节点的样式" class="headerlink" title="修改节点的样式"></a>修改节点的样式</h3><p><strong>格式 ： 元素对象.style.css属性名=”属性值”</strong><br>例如：  </p><ul><li>node.style.color  = “red”  </li><li>node.style.fontSize = “10em”   </li></ul><h3 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a><strong>面向对象</strong></h3><ul><li><p>类：一系列事务的抽象（提取），什么是人类。</p></li><li><p>对象：你就是对象。</p></li><li><p>属性：描述一类事物的名词。</p></li><li><p>方法：描述一类事物的动词。</p></li></ul><hr><h4 id="创建对象的三种方式"><a href="#创建对象的三种方式" class="headerlink" title="创建对象的三种方式"></a><strong>创建对象的三种方式</strong></h4><ol><li><p>使用object </p> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span>  user  =   <span class="keyword">new</span>   <span class="built_in">Object</span>();  </span><br><span class="line">user.name  =  <span class="string">"kobe"</span>;   属性赋值  </span><br><span class="line">  user.age    =   <span class="number">40</span>  ;  </span><br><span class="line">  user.say   =  <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;    定义方法</span><br><span class="line">alert(<span class="keyword">this</span>.name);</span><br><span class="line">   &#125;</span><br><span class="line">  user.say();  调用方法</span><br></pre></td></tr></table></figure></li><li><p>使用构造 </p></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>  <span class="title">user</span>(<span class="params">name ,age </span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name  = name;</span><br><span class="line">    <span class="keyword">this</span>.age  = age;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">this</span>.say  = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            alert(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>使用直接量 （JSON对象）  </li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span>   user = &#123;</span><br><span class="line">    name:<span class="string">"james"</span>,</span><br><span class="line">    age:<span class="number">21</span>,</span><br><span class="line">    say:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        alert(<span class="string">"你好，我是"</span>+<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">user.say();</span><br></pre></td></tr></table></figure><h4 id="JSON对象"><a href="#JSON对象" class="headerlink" title="JSON对象"></a><strong>JSON对象</strong></h4><ol><li>json对象</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span>    j     =   &#123;</span><br><span class="line">          <span class="string">"name"</span>: <span class="string">"yangxin"</span>,</span><br><span class="line">          <span class="string">"age"</span>: <span class="number">19</span></span><br><span class="line">&#125;;</span><br><span class="line">alert(    j.name );</span><br><span class="line">alert(    j.age     );</span><br></pre></td></tr></table></figure><ol start="2"><li>json数组  </li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span>    j    =    [&#123;</span><br><span class="line">    <span class="string">"name"</span>:   <span class="string">"a"</span>,</span><br><span class="line">    <span class="string">"age"</span>:  <span class="number">20</span></span><br><span class="line">&#125;,&#123;</span><br><span class="line">    <span class="string">"name"</span>:   <span class="string">"b"</span>,</span><br><span class="line">    <span class="string">"age"</span>:  <span class="number">21</span></span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">alert(    j[<span class="number">0</span>].name    )</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>第十五天啦</title>
      <link href="/2019/10/08/2019-08-28-fiveteen/"/>
      <url>/2019/10/08/2019-08-28-fiveteen/</url>
      
        <content type="html"><![CDATA[<h2 id="第十五天了"><a href="#第十五天了" class="headerlink" title="第十五天了"></a>第十五天了</h2><hr><p><strong>来兄弟会半个月了，终于将系统性的东西学完了，开始进入到专业课程了，今天学js，虽然之前在Java双元班学过一遍，但还是要再巩固再加深一遍印象，毕竟学无止境。</strong></p><hr><h2 id="本阶段任务"><a href="#本阶段任务" class="headerlink" title="本阶段任务"></a>本阶段任务</h2><ol><li>定时器   </li><li>选择对象  </li><li>改css样式  </li><li>创建对象  </li><li>弹出框  </li><li>流程控制   s</li><li>浏览器的兼容性问题  </li><li>node.js只需要学socket问题  </li><li>node的需求不是很大，只需要拿他做一个及时通讯（聊天室）  </li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>第十四天啦</title>
      <link href="/2019/10/08/2019-08-27-fourteen/"/>
      <url>/2019/10/08/2019-08-27-fourteen/</url>
      
        <content type="html"><![CDATA[<h2 id="第十四天啦"><a href="#第十四天啦" class="headerlink" title="第十四天啦"></a>第十四天啦</h2><hr><p><strong>今天可算把Lunix系统的命令过关了，太不容易了，弄了好几天，终于结束了进入到下一个学习目标。加油！今晚就要把Linux的流程图和思维导图弄明白。</strong></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>第十三天啦</title>
      <link href="/2019/10/08/2019-08-26-%E5%8D%81%E4%B8%89/"/>
      <url>/2019/10/08/2019-08-26-%E5%8D%81%E4%B8%89/</url>
      
        <content type="html"><![CDATA[<p><strong>## 第十三天啦</strong>  </p><p>-–  </p><p><strong><em>\</em>又是新的一周，这几天团建有点过了，心要收一收了，毕竟学业重要。今天把Linux系统常用命令全过了一遍，明天考试，过了之后开始进行下一阶段。加油！不对，今天还有件事，9点我的狗平告诉我他处对象了，他终于会拱白菜了，挺好，我还挺开心。放一张他的照片吧**</strong></p><p><img src="https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1566826209740&di=302bc2812eb9416f878d5a0dd2af1f00&imgtype=0&src=http%3A%2F%2Fn.sinaimg.cn%2Fsinacn%2Fw700h700%2F20180106%2Fe4fd-fyqincu7839758.jpg" alt></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>用户，组的操作</title>
      <link href="/2019/10/08/2019-08-26-%E6%8A%80%E6%9C%AF/"/>
      <url>/2019/10/08/2019-08-26-%E6%8A%80%E6%9C%AF/</url>
      
        <content type="html"><![CDATA[<h3 id="用户，组的基本操作命令"><a href="#用户，组的基本操作命令" class="headerlink" title="用户，组的基本操作命令"></a>用户，组的基本操作命令</h3><ol><li>用户的基本操作  </li></ol><p>​        创建用户  useradd -d 目录  name  </p><p>​        查看用户  /home/   ll</p><p>​        删除用户  userdel   name(保留家目录)      /   userdel  -r  name  (全删)      </p><p>​        修改用户  passwd name  设置密码</p><p>​        切换用户  su  -  用户名  （向权限低的用户切换不需要输入密码）</p><ol start="2"><li>组的基本操作  </li></ol><p>​        创建组   groupadd  组名       useradd  -g   组名   用户名</p><p>​        删除组    groupdel  组名</p><p>​        修改用户的组    usermod   -g  组名    用户名</p><ol start="3"><li>/etc/passwd   用户配置文件</li></ol><p>​        /etc/shadow   口令配置文件</p><p>​        /etc/group     组配置文件   </p><ol start="4"><li>如何找回丢失的root密码</li></ol><p>​        思路：进入到单用户模式，然后修改root密码，因为进入单用户模式，root不需要密码就可以登录</p><p>​     d 是目录文件  </p><p>​     l  是软连接  </p><p>​     c  字符设备 键盘，鼠标  </p><p>​     b 块文件，硬盘  </p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>第十天啦</title>
      <link href="/2019/10/08/2019-08-23-ten/"/>
      <url>/2019/10/08/2019-08-23-ten/</url>
      
        <content type="html"><![CDATA[<h1 id="日报"><a href="#日报" class="headerlink" title="日报"></a>日报</h1><h2 id="第十天啦"><a href="#第十天啦" class="headerlink" title="第十天啦"></a>第十天啦</h2><hr><p><strong>时间过的真快，进来兄弟会已经有十天了，这里遇到的同事都很不错。已经慢慢的融入这个大家庭,熟悉了这个学习模式，跟有利于以后的发展，</strong></p><p><em>下午不知道怎么回事，身体不太舒服拉肚子，学习效率差了点，明天明天一定要补回来！！！</em></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>VIM常用按键</title>
      <link href="/2019/10/08/2019-08-22-vim%E5%B8%B8%E7%94%A8%E6%8C%89%E9%94%AE/"/>
      <url>/2019/10/08/2019-08-22-vim%E5%B8%B8%E7%94%A8%E6%8C%89%E9%94%AE/</url>
      
        <content type="html"><![CDATA[<h3 id="第一部份：一般模式可用的光标移动、复制粘贴、搜索替换等"><a href="#第一部份：一般模式可用的光标移动、复制粘贴、搜索替换等" class="headerlink" title="第一部份：一般模式可用的光标移动、复制粘贴、搜索替换等"></a>第一部份：一般模式可用的光标移动、复制粘贴、搜索替换等</h3><table><thead><tr><th align="left">移动光标的方法</th><th></th></tr></thead><tbody><tr><td align="left">h 或 向左箭头键(←)</td><td>光标向左移动一个字符</td></tr><tr><td align="left">j 或 向下箭头键(↓)</td><td>光标向下移动一个字符</td></tr><tr><td align="left">k 或 向上箭头键(↑)</td><td>光标向上移动一个字符</td></tr><tr><td align="left">l 或 向右箭头键(→)</td><td>光标向右移动一个字符</td></tr><tr><td align="left">如果你将右手放在键盘上的话，你会发现 hjkl 是排列在一起的，因此可以使用这四个按钮来移动光标。 如果想要进行多次移动的话，例如向下移动 30 行，可以使用 “30j” 或 “30↓” 的组合按键， 亦即加上想要进行的次数(数字)后，按下动作即可！</td><td></td></tr><tr><td align="left">[Ctrl] + [f]</td><td>屏幕『向下』移动一页，相当于 [Page Down]按键 (常用)</td></tr><tr><td align="left">[Ctrl] + [b]</td><td>屏幕『向上』移动一页，相当于 [Page Up] 按键 (常用)</td></tr><tr><td align="left">[Ctrl] + [d]</td><td>屏幕『向下』移动半页</td></tr><tr><td align="left">[Ctrl] + [u]</td><td>屏幕『向上』移动半页</td></tr><tr><td align="left">+</td><td>光标移动到非空格符的下一行</td></tr><tr><td align="left">-</td><td>光标移动到非空格符的上一行</td></tr><tr><td align="left">n<space></space></td><td>那个 n 表示『数字』，例如 20 。按下数字后再按空格键，光标会向右移动这一行的 n 个字符。例如 20<space> 则光标会向后面移动 20 个字符距离。</space></td></tr><tr><td align="left">0 或功能键[Home]</td><td>这是数字『 0 』：移动到这一行的最前面字符处 (常用)</td></tr><tr><td align="left">$ 或功能键[End]</td><td>移动到这一行的最后面字符处(常用)</td></tr><tr><td align="left">H</td><td>光标移动到这个屏幕的最上方那一行的第一个字符</td></tr><tr><td align="left">M</td><td>光标移动到这个屏幕的中央那一行的第一个字符</td></tr><tr><td align="left">L</td><td>光标移动到这个屏幕的最下方那一行的第一个字符</td></tr><tr><td align="left">G</td><td>移动到这个档案的最后一行(常用)</td></tr><tr><td align="left">nG</td><td>n 为数字。移动到这个档案的第 n 行。例如 20G 则会移动到这个档案的第 20 行(可配合 :set nu)</td></tr><tr><td align="left">gg</td><td>移动到这个档案的第一行，相当于 1G 啊！ (常用)</td></tr><tr><td align="left">n<enter></enter></td><td>n 为数字。光标向下移动 n 行(常用)</td></tr><tr><td align="left">搜索替换</td><td></td></tr><tr><td align="left">/word</td><td>向光标之下寻找一个名称为 word 的字符串。例如要在档案内搜寻 vbird 这个字符串，就输入 /vbird 即可！ (常用)</td></tr><tr><td align="left">?word</td><td>向光标之上寻找一个字符串名称为 word 的字符串。</td></tr><tr><td align="left">n</td><td>这个 n 是英文按键。代表重复前一个搜寻的动作。举例来说， 如果刚刚我们执行 /vbird 去向下搜寻 vbird 这个字符串，则按下 n 后，会向下继续搜寻下一个名称为 vbird 的字符串。如果是执行 ?vbird 的话，那么按下 n 则会向上继续搜寻名称为 vbird 的字符串！</td></tr><tr><td align="left">N</td><td>这个 N 是英文按键。与 n 刚好相反，为『反向』进行前一个搜寻动作。 例如 /vbird 后，按下 N 则表示『向上』搜寻 vbird 。</td></tr><tr><td align="left">使用 /word 配合 n 及 N 是非常有帮助的！可以让你重复的找到一些你搜寻的关键词！</td><td></td></tr><tr><td align="left">:n1,n2s/word1/word2/g</td><td>n1 与 n2 为数字。在第 n1 与 n2 行之间寻找 word1 这个字符串，并将该字符串取代为 word2 ！举例来说，在 100 到 200 行之间搜寻 vbird 并取代为 VBIRD 则： 『:100,200s/vbird/VBIRD/g』。(常用)</td></tr><tr><td align="left"><strong>:1,$s/word1/word2/g</strong> 或 <strong>:%s/word1/word2/g</strong></td><td>从第一行到最后一行寻找 word1 字符串，并将该字符串取代为 word2 ！(常用)</td></tr><tr><td align="left"><strong>:1,$s/word1/word2/gc</strong> 或 <strong>:%s/word1/word2/gc</strong></td><td>从第一行到最后一行寻找 word1 字符串，并将该字符串取代为 word2 ！且在取代前显示提示字符给用户确认 (confirm) 是否需要取代！(常用)</td></tr><tr><td align="left">删除、复制与贴上</td><td></td></tr><tr><td align="left">x, X</td><td>在一行字当中，x 为向后删除一个字符 (相当于 [del] 按键)， X 为向前删除一个字符(相当于 [backspace] 亦即是退格键) (常用)</td></tr><tr><td align="left">nx</td><td>n 为数字，连续向后删除 n 个字符。举例来说，我要连续删除 10 个字符， 『10x』。</td></tr><tr><td align="left">dd</td><td>删除游标所在的那一整行(常用)</td></tr><tr><td align="left">ndd</td><td>n 为数字。删除光标所在的向下 n 行，例如 20dd 则是删除 20 行 (常用)</td></tr><tr><td align="left">d1G</td><td>删除光标所在到第一行的所有数据</td></tr><tr><td align="left">dG</td><td>删除光标所在到最后一行的所有数据</td></tr><tr><td align="left">d$</td><td>删除游标所在处，到该行的最后一个字符</td></tr><tr><td align="left">d0</td><td>那个是数字的 0 ，删除游标所在处，到该行的最前面一个字符</td></tr><tr><td align="left">yy</td><td>复制游标所在的那一行(常用)</td></tr><tr><td align="left">nyy</td><td>n 为数字。复制光标所在的向下 n 行，例如 20yy 则是复制 20 行(常用)</td></tr><tr><td align="left">y1G</td><td>复制游标所在行到第一行的所有数据</td></tr><tr><td align="left">yG</td><td>复制游标所在行到最后一行的所有数据</td></tr><tr><td align="left">y0</td><td>复制光标所在的那个字符到该行行首的所有数据</td></tr><tr><td align="left">y$</td><td>复制光标所在的那个字符到该行行尾的所有数据</td></tr><tr><td align="left">p, P</td><td>p 为将已复制的数据在光标下一行贴上，P 则为贴在游标上一行！ 举例来说，我目前光标在第 20 行，且已经复制了 10 行数据。则按下 p 后， 那 10 行数据会贴在原本的 20 行之后，亦即由 21 行开始贴。但如果是按下 P 呢？ 那么原本的第 20 行会被推到变成 30 行。 (常用)</td></tr><tr><td align="left">J</td><td>将光标所在行与下一行的数据结合成同一行</td></tr><tr><td align="left">c</td><td>重复删除多个数据，例如向下删除 10 行，[ 10cj ]</td></tr><tr><td align="left">u</td><td>复原前一个动作。(常用)</td></tr><tr><td align="left">[Ctrl]+r</td><td>重做上一个动作。(常用)</td></tr><tr><td align="left">这个 u 与 [Ctrl]+r 是很常用的指令！一个是复原，另一个则是重做一次～ 利用这两个功能按键，你的编辑，嘿嘿！很快乐的啦！</td><td></td></tr><tr><td align="left">.</td><td>不要怀疑！这就是小数点！意思是重复前一个动作的意思。 如果你想要重复删除、重复贴上等等动作，按下小数点『.』就好了！ (常用)</td></tr></tbody></table><h3 id="第二部份：一般模式切换到编辑模式的可用的按钮说明"><a href="#第二部份：一般模式切换到编辑模式的可用的按钮说明" class="headerlink" title="第二部份：一般模式切换到编辑模式的可用的按钮说明"></a>第二部份：一般模式切换到编辑模式的可用的按钮说明</h3><table><thead><tr><th align="left">进入输入或取代的编辑模式</th><th></th></tr></thead><tbody><tr><td align="left">i, I</td><td>进入输入模式(Insert mode)： i 为『从目前光标所在处输入』， I 为『在目前所在行的第一个非空格符处开始输入』。 (常用)</td></tr><tr><td align="left">a, A</td><td>进入输入模式(Insert mode)： a 为『从目前光标所在的下一个字符处开始输入』， A 为『从光标所在行的最后一个字符处开始输入』。(常用)</td></tr><tr><td align="left">o, O</td><td>进入输入模式(Insert mode)： 这是英文字母 o 的大小写。o 为『在目前光标所在的下一行处输入新的一行』； O 为在目前光标所在处的上一行输入新的一行！(常用)</td></tr><tr><td align="left">r, R</td><td>进入取代模式(Replace mode)： r 只会取代光标所在的那一个字符一次；R会一直取代光标所在的文字，直到按下 ESC 为止；(常用)</td></tr><tr><td align="left">上面这些按键中，在 vi 画面的左下角处会出现『–INSERT–』或『–REPLACE–』的字样。 由名称就知道该动作了吧！！特别注意的是，我们上面也提过了，你想要在档案里面输入字符时， 一定要在左下角处看到 INSERT 或 REPLACE 才能输入喔！</td><td></td></tr><tr><td align="left">[Esc]</td><td>退出编辑模式，回到一般模式中(常用)</td></tr></tbody></table><h3 id="第三部份：一般模式切换到指令行模式的可用的按钮说明"><a href="#第三部份：一般模式切换到指令行模式的可用的按钮说明" class="headerlink" title="第三部份：一般模式切换到指令行模式的可用的按钮说明"></a>第三部份：一般模式切换到指令行模式的可用的按钮说明</h3><table><thead><tr><th align="left">指令行的储存、离开等指令</th><th></th></tr></thead><tbody><tr><td align="left">:w</td><td>将编辑的数据写入硬盘档案中(常用)</td></tr><tr><td align="left">:w!</td><td>若文件属性为『只读』时，强制写入该档案。不过，到底能不能写入， 还是跟你对该档案的档案权限有关啊！</td></tr><tr><td align="left">:q</td><td>离开 vi (常用)</td></tr><tr><td align="left">:q!</td><td>若曾修改过档案，又不想储存，使用 ! 为强制离开不储存档案。</td></tr><tr><td align="left">注意一下啊，那个惊叹号 (!) 在 vi 当中，常常具有『强制』的意思～</td><td></td></tr><tr><td align="left">:wq</td><td>储存后离开，若为 :wq! 则为强制储存后离开 (常用)</td></tr><tr><td align="left">ZZ</td><td>这是大写的 Z 喔！若档案没有更动，则不储存离开，若档案已经被更动过，则储存后离开！</td></tr><tr><td align="left">:w [filename]</td><td>将编辑的数据储存成另一个档案（类似另存新档）</td></tr><tr><td align="left">:r [filename]</td><td>在编辑的数据中，读入另一个档案的数据。亦即将 『filename』 这个档案内容加到游标所在行后面</td></tr><tr><td align="left">:n1,n2 w [filename]</td><td>将 n1 到 n2 的内容储存成 filename 这个档案。</td></tr><tr><td align="left">:! command</td><td>暂时离开 vi 到指令行模式下执行 command 的显示结果！例如 『:! ls /home』即可在 vi 当中察看 /home 底下以 ls 输出的档案信息！</td></tr><tr><td align="left">set nu</td><td>显示每一行的行号</td></tr><tr><td align="left">set nonu</td><td>取消显示每一行的行号</td></tr></tbody></table>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>QQ安装</title>
      <link href="/2019/10/08/2019-08-22-QQ%E5%AE%89%E8%A3%85/"/>
      <url>/2019/10/08/2019-08-22-QQ%E5%AE%89%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<h1 id="安装-wine"><a href="#安装-wine" class="headerlink" title="安装 wine"></a>安装 wine</h1><p>git clone <a href="https://gitee.com/wszqkzqk/deepin-wine-for-ubuntu.git" target="_blank" rel="noopener">https://gitee.com/wszqkzqk/deepin-wine-for-ubuntu.git</a><br>cd deepin-wine-for-ubuntu<br>sudo sh install.sh    </p><h1 id="安装-QQ"><a href="#安装-QQ" class="headerlink" title="安装 QQ"></a>安装 QQ</h1><p>wget <a href="http://mirrors.aliyun.com/deepin/pool/non-free/d/deepin.com.qq.im/deepin.com.qq.im_8.9.19983deepin23_i386.deb" target="_blank" rel="noopener">http://mirrors.aliyun.com/deepin/pool/non-free/d/deepin.com.qq.im/deepin.com.qq.im_8.9.19983deepin23_i386.deb</a><br>sudo dpkg -i deepin.com.qq.im_8.9.19983deepin23_i386.deb<br>sudo apt-get install -f    </p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>第九天日报</title>
      <link href="/2019/10/08/2019-08-22-nine/"/>
      <url>/2019/10/08/2019-08-22-nine/</url>
      
        <content type="html"><![CDATA[<p><strong>#  第九天啦</strong> </p><p><strong><em>\</em>今天学的知识就比较多了，学了VIM还有Linux系统的操作指令，真的是太多了，400多个，属实有点背不下来啊。但是我把常用的几十个 指令都在shell窗口里打了一遍，基本都有了印象，以后会慢慢熟悉的。**</strong>  </p><p><img src="https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1566530606129&di=2c9d557a1c47156de3abf8551bf27076&imgtype=0&src=http%3A%2F%2Fimg.mp.itc.cn%2Fupload%2F20170710%2F14110e5722984f3386b9fcdc00737c2e_th.jpg" alt></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux</title>
      <link href="/2019/10/08/2019-08-22-Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
      <url>/2019/10/08/2019-08-22-Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<p><strong>Linux常用命令大全（非常全！！！）</strong></p><p>最近都在和Linux打交道，感觉还不错。我觉得Linux相比windows比较麻烦的就是很多东西都要用命令来控制，当然，这也是很多人喜欢linux的原因，比较短小但却功能强大。我将我了解到的命令列举一下，仅供大家参考： </p><p><strong>系统信息</strong><br>arch 显示机器的处理器架构<br>uname -m 显示机器的处理器架构<br>uname -r 显示正在使用的内核版本<br>dmidecode -q 显示硬件系统部件 - (SMBIOS / DMI)<br>hdparm -i /dev/hda 罗列一个磁盘的架构特性<br>hdparm -tT /dev/sda 在磁盘上执行测试性读取操作<br>cat /proc/cpuinfo 显示CPU info的信息<br>cat /proc/interrupts 显示中断<br>cat /proc/meminfo 校验内存使用<br>cat /proc/swaps 显示哪些swap被使用<br>cat /proc/version 显示内核的版本<br>cat /proc/net/dev 显示网络适配器及统计<br>cat /proc/mounts 显示已加载的文件系统<br>lspci -tv 罗列 PCI 设备<br>lsusb -tv 显示 USB 设备<br>date 显示系统日期<br>cal 2007 显示2007年 的日历表<br>date 041217002007.00 设置日期和时间 - 月日时分年.秒<br>clock -w 将时间修改保存到 BIOS              </p><p><strong>关机 (系统的关机、重启以及登出 )</strong><br>shutdown -h now 关闭系统<br>init 0 关闭系统<br>telinit 0 关闭系统<br>shutdown -h hours:minutes &amp; 按预定时间关闭系统<br>shutdown -c 取消按预定时间关闭系统<br>shutdown -r now 重启<br>reboot 重启<br>logout 注销       </p><p><strong>文件和目录</strong><br>cd /home 进入 ‘/ home’ 目录’<br>cd .. 返回上一级目录<br>cd ../.. 返回上两级目录<br>cd 进入个人的主目录<br>cd ~user1 进入个人的主目录<br>cd - 返回上次所在的目录<br>pwd 显示工作路径<br>ls 查看目录中的文件<br>ls -F 查看目录中的文件<br>ls -l 显示文件和目录的详细资料<br>ls -a 显示隐藏文件<br>ls <em>[0-9]</em> 显示包含数字的文件名和目录名<br>tree 显示文件和目录由根目录开始的树形结构<br>lstree 显示文件和目录由根目录开始的树形结构<br>mkdir dir1 创建一个叫做 ‘dir1’ 的目录’  </p><p>kdir dir1 dir2 同时创建两个目录<br>mkdir -p /tmp/dir1/dir2 创建一个目录树<br>rm -f file1 删除一个叫做 ‘file1’ 的文件’<br>rmdir dir1 删除一个叫做 ‘dir1’ 的目录’<br>rm -rf dir1 删除一个叫做 ‘dir1’ 的目录并同时删除其内容<br>rm -rf dir1 dir2 同时删除两个目录及它们的内容<br>mv dir1 new_dir 重命名/移动 一个目录<br>cp file1 file2 复制一个文件<br>cp dir/* . 复制一个目录下的所有文件到当前工作目录<br>cp -a /tmp/dir1 . 复制一个目录到当前工作目录<br>cp -a dir1 dir2 复制一个目录<br>ln -s file1 lnk1 创建一个指向文件或目录的软链接<br>ln file1 lnk1 创建一个指向文件或目录的物理链接<br>touch -t 0712250000 file1 修改一个文件或目录的时间戳 - (YYMMDDhhmm)<br>file file1 outputs the mime type of the file as text<br>iconv -l 列出已知的编码<br>iconv -f fromEncoding -t toEncoding inputFile &gt; outputFile creates a new from the given input file by assuming it is encoded in fromEncoding and converting it to toEncoding.<br>find . -maxdepth 1 -name *.jpg -print -exec convert “{}” -resize 80x60 “thumbs/{}” ; batch resize files in the current directory and send them to a thumbnails directory (requires convert from Imagemagick)   </p><p><strong>文件搜索</strong><br>find / -name file1 从 ‘/‘ 开始进入根文件系统搜索文件和目录<br>find / -user user1 搜索属于用户 ‘user1’ 的文件和目录<br>find /home/user1 -name *.bin 在目录 ‘/ home/user1’ 中搜索带有’.bin’ 结尾的文件<br>find /usr/bin -type f -atime +100 搜索在过去100天内未被使用过的执行文件<br>find /usr/bin -type f -mtime -10 搜索在10天内被创建或者修改过的文件<br>find / -name *.rpm -exec chmod 755 ‘{}’ ; 搜索以 ‘.rpm’ 结尾的文件并定义其权限<br>find / -xdev -name *.rpm 搜索以 ‘.rpm’ 结尾的文件，忽略光驱、捷盘等可移动设备<br>locate *.ps 寻找以 ‘.ps’ 结尾的文件 - 先运行 ‘updatedb’ 命令<br>whereis halt 显示一个二进制文件、源码或man的位置<br>which halt 显示一个二进制文件或可执行文件的完整路径   </p><p><strong>挂载一个文件系统</strong><br>mount /dev/hda2 /mnt/hda2 挂载一个叫做hda2的盘 - 确定目录 ‘/ mnt/hda2’ 已经存在<br>umount /dev/hda2 卸载一个叫做hda2的盘 - 先从挂载点 ‘/ mnt/hda2’ 退出<br>fuser -km /mnt/hda2 当设备繁忙时强制卸载<br>umount -n /mnt/hda2 运行卸载操作而不写入 /etc/mtab 文件- 当文件为只读或当磁盘写满时非常有用<br>mount /dev/fd0 /mnt/floppy 挂载一个软盘<br>mount /dev/cdrom /mnt/cdrom 挂载一个cdrom或dvdrom<br>mount /dev/hdc /mnt/cdrecorder 挂载一个cdrw或dvdrom<br>mount /dev/hdb /mnt/cdrecorder 挂载一个cdrw或dvdrom<br>mount -o loop file.iso /mnt/cdrom 挂载一个文件或ISO镜像文件<br>mount -t vfat /dev/hda5 /mnt/hda5 挂载一个Windows FAT32文件系统<br>mount /dev/sda1 /mnt/usbdisk 挂载一个usb 捷盘或闪存设备<br>mount -t smbfs -o username=user,password=pass //WinClient/share /mnt/share 挂载一个windows网络共享   </p><p><strong>磁盘空间</strong><br>df -h 显示已经挂载的分区列表<br>ls -lSr |more 以尺寸大小排列文件和目录<br>du -sh dir1 估算目录 ‘dir1’ 已经使用的磁盘空间’<br>du -sk * | sort -rn 以容量大小为依据依次显示文件和目录的大小<br>rpm -q -a –qf ‘%10{SIZE}t%{NAME}n’ | sort -k1,1n 以大小为依据依次显示已安装的rpm包所使用的空间 (fedora, redhat类系统)<br>dpkg-query -W -f=’${Installed-Size;10}t${Package}n’ | sort -k1,1n 以大小为依据显示已安装的deb包所使用的空间 (ubuntu, debian类系统)   </p><p><strong>用户和群组</strong><br>groupadd group_name 创建一个新用户组<br>groupdel group_name 删除一个用户组<br>groupmod -n new_group_name old_group_name 重命名一个用户组<br>useradd -c “Name Surname “ -g admin -d /home/user1 -s /bin/bash user1 创建一个属于 “admin” 用户组的用户<br>useradd user1 创建一个新用户<br>userdel -r user1 删除一个用户 ( ‘-r’ 排除主目录)<br>usermod -c “User FTP” -g system -d /ftp/user1 -s /bin/nologin user1 修改用户属性<br>passwd 修改口令<br>passwd user1 修改一个用户的口令 (只允许root执行)<br>chage -E 2005-12-31 user1 设置用户口令的失效期限<br>pwck 检查 ‘/etc/passwd’ 的文件格式和语法修正以及存在的用户<br>grpck 检查 ‘/etc/passwd’ 的文件格式和语法修正以及存在的群组<br>newgrp group_name 登陆进一个新的群组以改变新创建文件的预设群组   </p><p><strong>文件的权限 - 使用 “+” 设置权限，使用 “-“ 用于取消</strong><br>ls -lh 显示权限<br>ls /tmp | pr -T5 -W$COLUMNS 将终端划分成5栏显示<br>chmod ugo+rwx directory1 设置目录的所有人(u)、群组(g)以及其他人(o)以读（r ）、写(w)和执行(x)的权限<br>chmod go-rwx directory1 删除群组(g)与其他人(o)对目录的读写执行权限<br>chown user1 file1 改变一个文件的所有人属性<br>chown -R user1 directory1 改变一个目录的所有人属性并同时改变改目录下所有文件的属性<br>chgrp group1 file1 改变文件的群组<br>chown user1:group1 file1 改变一个文件的所有人和群组属性<br>find / -perm -u+s 罗列一个系统中所有使用了SUID控制的文件<br>chmod u+s /bin/file1 设置一个二进制文件的 SUID 位 - 运行该文件的用户也被赋予和所有者同样的权限<br>chmod u-s /bin/file1 禁用一个二进制文件的 SUID位<br>chmod g+s /home/public 设置一个目录的SGID 位 - 类似SUID ，不过这是针对目录的<br>chmod g-s /home/public 禁用一个目录的 SGID 位<br>chmod o+t /home/public 设置一个文件的 STIKY 位 - 只允许合法所有人删除文件<br>chmod o-t /home/public 禁用一个目录的 STIKY 位  </p><p><strong>文件的特殊属性 - 使用 “+” 设置权限，使用 “-“ 用于取消</strong><br>chattr +a file1 只允许以追加方式读写文件<br>chattr +c file1 允许这个文件能被内核自动压缩/解压<br>chattr +d file1 在进行文件系统备份时，dump程序将忽略这个文件<br>chattr +i file1 设置成不可变的文件，不能被删除、修改、重命名或者链接<br>chattr +s file1 允许一个文件被安全地删除<br>chattr +S file1 一旦应用程序对这个文件执行了写操作，使系统立刻把修改的结果写到磁盘<br>chattr +u file1 若文件被删除，系统会允许你在以后恢复这个被删除的文件<br>lsattr 显示特殊的属性  </p><p><strong>打包和压缩文件</strong><br>bunzip2 file1.bz2 解压一个叫做 ‘file1.bz2’的文件<br>bzip2 file1 压缩一个叫做 ‘file1’ 的文件<br>gunzip file1.gz 解压一个叫做 ‘file1.gz’的文件<br>gzip file1 压缩一个叫做 ‘file1’的文件<br>gzip -9 file1 最大程度压缩<br>rar a file1.rar test_file 创建一个叫做 ‘file1.rar’ 的包<br>rar a file1.rar file1 file2 dir1 同时压缩 ‘file1’, ‘file2’ 以及目录 ‘dir1’<br>rar x file1.rar 解压rar包<br>unrar x file1.rar 解压rar包<br>tar -cvf archive.tar file1 创建一个非压缩的 tarball<br>tar -cvf archive.tar file1 file2 dir1 创建一个包含了 ‘file1’, ‘file2’ 以及 ‘dir1’的档案文件<br>tar -tf archive.tar 显示一个包中的内容<br>tar -xvf archive.tar 释放一个包<br>tar -xvf archive.tar -C /tmp 将压缩包释放到 /tmp目录下<br>tar -cvfj archive.tar.bz2 dir1 创建一个bzip2格式的压缩包<br>tar -jxvf archive.tar.bz2 解压一个bzip2格式的压缩包<br>tar -cvfz archive.tar.gz dir1 创建一个gzip格式的压缩包<br>tar -zxvf archive.tar.gz 解压一个gzip格式的压缩包<br>zip file1.zip file1 创建一个zip格式的压缩包<br>zip -r file1.zip file1 file2 dir1 将几个文件和目录同时压缩成一个zip格式的压缩包<br>unzip file1.zip 解压一个zip格式压缩包   </p><p><strong>RPM 包 - （Fedora, Redhat及类似系统）</strong><br>rpm -ivh package.rpm 安装一个rpm包<br>rpm -ivh –nodeeps package.rpm 安装一个rpm包而忽略依赖关系警告<br>rpm -U package.rpm 更新一个rpm包但不改变其配置文件<br>rpm -F package.rpm 更新一个确定已经安装的rpm包<br>rpm -e package_name.rpm 删除一个rpm包<br>rpm -qa 显示系统中所有已经安装的rpm包<br>rpm -qa | grep httpd 显示所有名称中包含 “httpd” 字样的rpm包<br>rpm -qi package_name 获取一个已安装包的特殊信息<br>rpm -qg “System Environment/Daemons” 显示一个组件的rpm包<br>rpm -ql package_name 显示一个已经安装的rpm包提供的文件列表<br>rpm -qc package_name 显示一个已经安装的rpm包提供的配置文件列表<br>rpm -q package_name –whatrequires 显示与一个rpm包存在依赖关系的列表<br>rpm -q package_name –whatprovides 显示一个rpm包所占的体积<br>rpm -q package_name –scripts 显示在安装/删除期间所执行的脚本l<br>rpm -q package_name –changelog 显示一个rpm包的修改历史<br>rpm -qf /etc/httpd/conf/httpd.conf 确认所给的文件由哪个rpm包所提供<br>rpm -qp package.rpm -l 显示由一个尚未安装的rpm包提供的文件列表<br>rpm –import /media/cdrom/RPM-GPG-KEY 导入公钥数字证书<br>rpm –checksig package.rpm 确认一个rpm包的完整性<br>rpm -qa gpg-pubkey 确认已安装的所有rpm包的完整性<br>rpm -V package_name 检查文件尺寸、 许可、类型、所有者、群组、MD5检查以及最后修改时 间<br>rpm -Va 检查系统中所有已安装的rpm包- 小心使用<br>rpm -Vp package.rpm 确认一个rpm包还未安装<br>rpm2cpio package.rpm | cpio –extract –make-directories <em>bin</em> 从一个rpm包运行可执行文件<br>rpm -ivh /usr/src/redhat/RPMS/<code>arch</code>/package.rpm 从一个rpm源码安装一个构建好的包<br>rpmbuild –rebuild package_name.src.rpm 从一个rpm源码构建一个 rpm 包   </p><p><strong>YUM 软件包升级器 - （Fedora, RedHat及类似系统）</strong><br>yum install package_name 下载并安装一个rpm包<br>yum localinstall package_name.rpm 将安装一个rpm包，使用你自己的软件仓库为你解决所有依赖关系<br>yum update package_name.rpm 更新当前系统中所有安装的rpm包<br>yum update package_name 更新一个rpm包<br>yum remove package_name 删除一个rpm包<br>yum list 列出当前系统中安装的所有包<br>yum search package_name 在rpm仓库中搜寻软件包<br>yum clean packages 清理rpm缓存删除下载的包<br>yum clean headers 删除所有头文件<br>yum clean all 删除所有缓存的包和头文件   </p><p><strong>DEB 包 (Debian, Ubuntu 以及类似系统)</strong><br>dpkg -i package.deb 安装/更新一个 deb 包<br>dpkg -r package_name 从系统删除一个 deb 包<br>dpkg -l 显示系统中所有已经安装的 deb 包<br>dpkg -l | grep httpd 显示所有名称中包含 “httpd” 字样的deb包<br>dpkg -s package_name 获得已经安装在系统中一个特殊包的信息<br>dpkg -L package_name 显示系统中已经安装的一个deb包所提供的文件列表<br>dpkg –contents package.deb 显示尚未安装的一个包所提供的文件列表<br>dpkg -S /bin/ping 确认所给的文件由哪个deb包提供   </p><p><strong>APT 软件工具 (Debian, Ubuntu 以及类似系统)</strong><br>apt-get install package_name 安装/更新一个 deb 包<br>apt-cdrom install package_name 从光盘安装/更新一个 deb 包<br>apt-get update 升级列表中的软件包<br>apt-get upgrade 升级所有已安装的软件<br>apt-get remove package_name 从系统删除一个deb包<br>apt-get check 确认依赖的软件仓库正确<br>apt-get clean 从下载的软件包中清理缓存<br>apt-cache search searched-package 返回包含所要搜索字符串的软件包名称   </p><p><strong>查看文件内容</strong><br>cat file1 从第一个字节开始正向查看文件的内容<br>tac file1 从最后一行开始反向查看一个文件的内容<br>more file1 查看一个长文件的内容<br>less file1 类似于 ‘more’ 命令，但是它允许在文件中和正向操作一样的反向操作<br>head -2 file1 查看一个文件的前两行<br>tail -2 file1 查看一个文件的最后两行<br>tail -f /var/log/messages 实时查看被添加到一个文件中的内容    </p><p><strong>文本处理</strong><br>cat file1 file2 … | command &lt;&gt; file1_in.txt_or_file1_out.txt general syntax for text   manipulation using PIPE, STDIN and STDOUT<br>cat file1 | command( sed, grep, awk, grep, etc…) &gt; result.txt 合并一个文件的详细说明文本，并将简介写入一个新文件中<br>cat file1 | command( sed, grep, awk, grep, etc…) &gt;&gt; result.txt 合并一个文件的详细说明文本，并将简介写入一个已有的文件中<br>grep Aug /var/log/messages 在文件 ‘/var/log/messages’中查找关键词”Aug”<br>grep ^Aug /var/log/messages 在文件 ‘/var/log/messages’中查找以”Aug”开始的词汇<br>grep [0-9] /var/log/messages 选择 ‘/var/log/messages’ 文件中所有包含数字的行<br>grep Aug -R /var/log/* 在目录 ‘/var/log’ 及随后的目录中搜索字符串”Aug”<br>sed ‘s/stringa1/stringa2/g’ example.txt 将example.txt文件中的 “string1” 替换成 “string2”<br>sed ‘/^$/d’ example.txt 从example.txt文件中删除所有空白行<br>sed ‘/ <em>#/d; /^$/d’ example.txt 从example.txt文件中删除所有注释和空白行<br>echo ‘esempio’ | tr ‘[:lower:]’ ‘[:upper:]’ 合并上下单元格内容<br>sed -e ‘1d’ result.txt 从文件example.txt 中排除第一行<br>sed -n ‘/stringa1/p’ 查看只包含词汇 “string1”的行<br>sed -e ‘s/ *$//‘ example.txt 删除每一行最后的空白字符<br>sed -e ‘s/stringa1//g’ example.txt 从文档中只删除词汇 “string1” 并保留剩余全部<br>sed -n ‘1,5p;5q’ example.txt 查看从第一行到第5行内容<br>sed -n ‘5p;5q’ example.txt 查看第5行<br>sed -e ‘s/00</em>/0/g’ example.txt 用单个零替换多个零<br>cat -n file1 标示文件的行数<br>cat example.txt | awk ‘NR%2==1’ 删除example.txt文件中的所有偶  数行<br>echo a b c | awk ‘{print $1}’ 查看一行第一栏<br>echo a b c | awk ‘{print $1,$3}’ 查看一行的第一和第三栏<br>paste file1 file2 合并两个文件或两栏的内容<br>paste -d ‘+’ file1 file2 合并两个文件或两栏的内容，中间用”+”区分<br>sort file1 file2 排序两个文件的内容<br>sort file1 file2 | uniq 取出两个文件的并集(重复的行只保留一份)<br>sort file1 file2 | uniq -u 删除交集，留下其他的行<br>sort file1 file2 | uniq -d 取出两个文件的交集(只留下同时存在于两个文件中的文件)<br>comm -1 file1 file2 比较两个文件的内容只删除 ‘file1’ 所包含的内容<br>comm -2 file1 file2 比较两个文件的内容只删除 ‘file2’ 所包含的内容<br>comm -3 file1 file2 比较两个文件的内容只删除两个文件共有的部分   </p><p><strong>字符设置和文件格式转换</strong><br>dos2unix filedos.txt fileunix.txt 将一个文本文件的格式从MSDOS转换成UNIX<br>unix2dos fileunix.txt filedos.txt 将一个文本文件的格式从UNIX转换成MSDOS<br>recode ..HTML &lt; page.txt &gt; page.html 将一个文本文件转换成html<br>recode -l | more 显示所有允许的转换格式   </p><p><strong>文件系统分析</strong><br>badblocks -v /dev/hda1 检查磁盘hda1上的坏磁块<br>fsck /dev/hda1 修复/检查hda1磁盘上linux文件系统的完整性<br>fsck.ext2 /dev/hda1 修复/检查hda1磁盘上ext2文件系统的完整性<br>e2fsck /dev/hda1 修复/检查hda1磁盘上ext2文件系统的完整性<br>e2fsck -j /dev/hda1 修复/检查hda1磁盘上ext3文件系统的完整性<br>fsck.ext3 /dev/hda1 修复/检查hda1磁盘上ext3文件系统的完整性<br>fsck.vfat /dev/hda1 修复/检查hda1磁盘上fat文件系统的完整性<br>fsck.msdos /dev/hda1 修复/检查hda1磁盘上dos文件系统的完整性<br>dosfsck /dev/hda1 修复/检查hda1磁盘上dos文件系统的完整性   </p><p><strong>初始化一个文件系统</strong><br>mkfs /dev/hda1 在hda1分区创建一个文件系统<br>mke2fs /dev/hda1 在hda1分区创建一个linux ext2的文件系统<br>mke2fs -j /dev/hda1 在hda1分区创建一个linux ext3(日志型)的文件系统<br>mkfs -t vfat 32 -F /dev/hda1 创建一个 FAT32 文件系统<br>fdformat -n /dev/fd0 格式化一个软盘<br>mkswap /dev/hda3 创建一个swap文件系统   </p><p><strong>SWAP文件系统</strong><br>mkswap /dev/hda3 创建一个swap文件系统<br>swapon /dev/hda3 启用一个新的swap文件系统<br>swapon /dev/hda2 /dev/hdb3 启用两个swap分区   </p><p><strong>备份</strong><br>dump -0aj -f /tmp/home0.bak /home 制作一个 ‘/home’ 目录的完整备份<br>dump -1aj -f /tmp/home0.bak /home 制作一个 ‘/home’ 目录的交互式备份<br>restore -if /tmp/home0.bak 还原一个交互式备份<br>rsync -rogpav –delete /home /tmp 同步两边的目录<br>rsync -rogpav -e ssh –delete /home ip_address:/tmp 通过SSH通道rsync<br>rsync -az -e ssh –delete ip_addr:/home/public /home/local 通过ssh和压缩将一个远程目录同步到本地目录<br>rsync -az -e ssh –delete /home/local ip_addr:/home/public 通过ssh和压缩将本地目录同步到远程目录<br>dd bs=1M if=/dev/hda | gzip | ssh user@ip_addr ‘dd of=hda.gz’ 通过ssh在远程主机上执行一次备份本地磁盘的操作<br>dd if=/dev/sda of=/tmp/file1 备份磁盘内容到一个文件<br>tar -Puf backup.tar /home/user 执行一次对 ‘/home/user’ 目录的交互式备份操作<br>( cd /tmp/local/ &amp;&amp; tar c . ) | ssh -C user@ip_addr ‘cd /home/share/ &amp;&amp; tar x -p’ 通过ssh在远程目录中复制一个目录内容<br>( tar c /home ) | ssh -C user@ip_addr ‘cd /home/backup-home &amp;&amp; tar x -p’ 通过ssh在远程目录中复制一个本地目录<br>tar cf - . | (cd /tmp/backup ; tar xf - ) 本地将一个目录复制到另一个地方，保留原有权限及链接<br>find /home/user1 -name ‘<em>.txt’ | xargs cp -av –target-directory=/home/backup/ –parents 从一个目录查找并复制所有以 ‘.txt’ 结尾的文件到另一个目录<br>find /var/log -name ‘</em>.log’ | tar cv –files-from=- | bzip2 &gt; log.tar.bz2 查找所有以 ‘.log’ 结尾的文件并做成一个bzip包<br>dd if=/dev/hda of=/dev/fd0 bs=512 count=1 做一个将 MBR (Master Boot Record)内容复制到软盘的动作<br>dd if=/dev/fd0 of=/dev/hda bs=512 count=1 从已经保存到软盘的备份中恢复MBR内容  </p><p><strong>光盘</strong><br>cdrecord -v gracetime=2 dev=/dev/cdrom -eject blank=fast -force 清空一个可复写的光盘内容<br>mkisofs /dev/cdrom &gt; cd.iso 在磁盘上创建一个光盘的iso镜像文件<br>mkisofs /dev/cdrom | gzip &gt; cd_iso.gz 在磁盘上创建一个压缩了的光盘iso镜像文件<br>mkisofs -J -allow-leading-dots -R -V “Label CD” -iso-level 4 -o ./cd.iso data_cd 创建一个目录的iso镜像文件<br>cdrecord -v dev=/dev/cdrom cd.iso 刻录一个ISO镜像文件<br>gzip -dc cd_iso.gz | cdrecord dev=/dev/cdrom - 刻录一个压缩了的ISO镜像文件<br>mount -o loop cd.iso /mnt/iso 挂载一个ISO镜像文件<br>cd-paranoia -B 从一个CD光盘转录音轨到 wav 文件中<br>cd-paranoia – “-3” 从一个CD光盘转录音轨到 wav 文件中（参数-3）<br>cdrecord –scanbus 扫描总线以识别scsi通道<br>dd if=/dev/hdc | md5sum 校验一个设备的md5sum编码，例如一张 CD   </p><p><strong>网络 - （以太网和WIFI无线</strong>）<br>ifconfig eth0 显示一个以太网卡的配置<br>ifup eth0 启用一个 ‘eth0’ 网络设备<br>ifdown eth0 禁用一个 ‘eth0’ 网络设备<br>ifconfig eth0 192.168.1.1 netmask 255.255.255.0 控制IP地址<br>ifconfig eth0 promisc 设置 ‘eth0’ 成混杂模式以嗅探数据包 (sniffing)<br>dhclient eth0 以dhcp模式启用 ‘eth0’<br>route -n show routing table<br>route add -net 0/0 gw IP_Gateway configura default gateway<br>route add -net 192.168.0.0 netmask 255.255.0.0 gw 192.168.1.1 configure static route to reach   network ‘192.168.0.0/16’<br>route del 0/0 gw IP_gateway remove static route<br>echo “1” &gt; /proc/sys/net/ipv4/ip_forward activate ip routing<br>hostname show hostname of system<br>host <a href="http://www.example.com" target="_blank" rel="noopener">www.example.com</a> lookup hostname to resolve name to ip address and viceversa<br>nslookup <a href="http://www.example.com" target="_blank" rel="noopener">www.example.com</a> lookup hostname to resolve name to ip address and viceversa<br>ip link show show link status of all interfaces<br>mii-tool eth0 show link status of ‘eth0’<br>ethtool eth0 show statistics of network card ‘eth0’<br>netstat -tup show all active network connections and their PID<br>netstat -tupl show all network services listening on the system and their PID<br>tcpdump tcp port 80 show all HTTP traffic<br>iwlist scan show wireless networks<br>iwconfig eth1 show configuration of a wireless network card<br>hostname show hostname<br>host <a href="http://www.example.com" target="_blank" rel="noopener">www.example.com</a> lookup hostname to resolve name to ip address and viceversa<br>nslookup <a href="http://www.example.com" target="_blank" rel="noopener">www.example.com</a> lookup hostname to resolve name to ip address and viceversa<br>whois <a href="http://www.example.com" target="_blank" rel="noopener">www.example.com</a> lookup on Whois database   </p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Git命令大总结</title>
      <link href="/2019/10/08/2019-08-21-Git/"/>
      <url>/2019/10/08/2019-08-21-Git/</url>
      
        <content type="html"><![CDATA[<h1 id="Git命令"><a href="#Git命令" class="headerlink" title="Git命令"></a>Git命令</h1><table><thead><tr><th>命令</th><th>说明</th><th>备注</th></tr></thead><tbody><tr><td>$ git config –global merge.tool vimdiff</td><td>在初次配置git时候要县配置一个差异分析工具如：vimdiff</td><td></td></tr><tr><td>$git init</td><td>初始化git库</td><td></td></tr><tr><td>$ git clone git</td><td>科隆git库</td><td></td></tr><tr><td>git config –global core.editor emacs</td><td>设置默认使用的文本编译器</td><td></td></tr><tr><td>$ git config –global merge.tool vimdiff</td><td>差异分析工具</td><td></td></tr><tr><td>git config —list</td><td>查看git的配置信息</td><td>有时候会看到重复的变量名，那就说明它们来自不同的配置文件（比如 /etc/gitconfig 和 ~/.gitconfig），不过最终 Git 实际采用的是最后一个。</td></tr><tr><td>$ git help config</td><td>查看git中的各种工具怎么使用</td><td></td></tr><tr><td>git config –list</td><td>检查已有的配置信息</td><td></td></tr><tr><td>git add 文件名</td><td>添加追踪文件，如果不写文件名就是该目录下的所有文件添加跟踪</td><td>多功能命令可以开始追踪文件 也可以把已追踪的文件放入暂存区</td></tr><tr><td>$ git commit -m ‘initial project version’</td><td>提交到暂存区</td><td>-m可以不加，如果不加就是可以长篇大论，将在git log中现实</td></tr><tr><td>git commit -a -m‘一段文字’</td><td>跳过暂存 省略 git add –all环节</td><td></td></tr><tr><td>git clone <a href="https://github.com/用户名/用户名.github.io" target="_blank" rel="noopener">https://github.com/用户名/用户名.github.io</a></td><td>科隆GITHUB上的数据库到本地</td><td>你在命令匡当前位置在哪就会科隆到哪</td></tr><tr><td>git status</td><td>检查当前文件状态</td><td>可以检查哪些文件是放入暂存区了，哪些文件未放入暂存区</td></tr><tr><td>git log</td><td>进入到库以后查看谁在什么时间修改了文件</td><td></td></tr><tr><td>git diff</td><td>查看为暂存和暂存区的差别</td><td></td></tr><tr><td>git diff –cached</td><td>查看上次提交和未暂存区的差别</td><td></td></tr><tr><td>git rm 删除的文件</td><td>删除文件</td><td></td></tr><tr><td>git rm –cached 文件</td><td>将文件在暂存区删除也就是取消跟踪</td><td>如果删除之前修改过并且已经放到暂存区域的话，则必须要用强制删除选项 -f</td></tr><tr><td>git mv 原路径+文件名     新路径+文件名</td><td>修改文件位置   也可以改名</td><td>前提是必须版本控制，也就是必须跟踪</td></tr><tr><td>git log</td><td>检查提交记录</td><td>我们常用 -p 选项展开显示每次提交的内容差异，用 -2 则仅显示最近的两次更新       –stat，仅显示简要的增改行数统计：用 oneline 将每个提交放在一行显示，这在提交数很大时非常有用。另外还有 short，full 和 fuller 可以用，展示的信息或多或少有些不同，请自己动手实践一下看看效果如何，$ git log –since=2.weeks就是近两周的提交</td></tr><tr><td>git log –oneline</td><td>显示在一行</td><td></td></tr><tr><td>git reflog</td><td>显示回退到某个修改需要退几步</td><td></td></tr><tr><td>$ git commit –amend</td><td>修改最后提交 也可以说是撤销最后一次提交</td><td></td></tr><tr><td>git checkout 文件名</td><td>抛弃修改命令，保证回到之前的版本</td><td></td></tr><tr><td>git remote</td><td>可以查看当时配置的有哪些远程库，加上-v显示对应的科隆地址</td><td>不加V的时候它会列出每个远程库的简短名字。在克隆完某个项目后，至少可以看到一个名为 origin 的远程库，Git 默认使用这个名字来标识你所克隆的原始仓库：</td></tr><tr><td>$ git fetch origin</td><td>从远程仓库抓取数据 正如之前所看到的，可以用下面的命令从远程仓库抓取数据到本地：</td><td></td></tr><tr><td>git remote show 远程库名</td><td>查看远程库配置信息</td><td></td></tr><tr><td>git remote add 别名  远程库地质</td><td>给远程库添加别名</td><td></td></tr><tr><td>git remote rename 老名字 新名字</td><td>修改远程库名字</td><td></td></tr><tr><td>$ git remote rm 库名</td><td>删除远程库</td><td></td></tr><tr><td>$git pull</td><td>分支取下来自动合并</td><td></td></tr><tr><td>git tag -a 标签名  -m’作出说明’</td><td>含注标签   -m后跟标签的说明</td><td></td></tr><tr><td>$ git tag -s v1.5 -m ‘my signed 1.5 tag’</td><td>-s 签署标签</td><td></td></tr><tr><td>$ git tag 标签名-lw</td><td>轻量级标签</td><td></td></tr><tr><td>git tag -v 标签名 -lw</td><td>验证签署标签</td><td></td></tr><tr><td>$ git push origin 标签名</td><td>发送标签到远程服务器</td><td></td></tr><tr><td>git branch 分支名字</td><td>创建分支</td><td></td></tr><tr><td>git checkout 分支名字</td><td>切换分支</td><td></td></tr><tr><td>git reset –hard 回退历史的索引值</td><td>改变head指针指向的位置</td><td></td></tr><tr><td>git reset –hard</td><td>显示当前HEAD命令在哪个修改上</td><td></td></tr><tr><td>git merge 要合并进来的分支名</td><td>合并分支</td><td></td></tr><tr><td>git branch -d 分支名字</td><td>删除分支</td><td></td></tr><tr><td>git branch</td><td>查看所有分支信息</td><td></td></tr><tr><td>git branch -v</td><td>查看各个分支最后一个提交的对象</td><td></td></tr><tr><td>git branch –merge</td><td>查看哪些分支已被并入当前分支</td><td></td></tr><tr><td>git branch –no-merged</td><td>查看尚未合并的工作</td><td></td></tr><tr><td>git push (远程仓库名) (分支名)</td><td>推送分支到远程仓库</td><td></td></tr><tr><td>$ git checkout -b sf origin/serverfix</td><td>跟踪远程分支</td><td></td></tr><tr><td>$ git rebase master</td><td>衍合操作</td><td></td></tr><tr><td>git rebase –onto 合并的分支 分支1  分支2</td><td>衍合操作改变基底分支，将分支1和分支2都为共同祖先的直接分支</td><td></td></tr></tbody></table>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>拉取分支和删除分支</title>
      <link href="/2019/10/08/2019-08-21-eightjishu/"/>
      <url>/2019/10/08/2019-08-21-eightjishu/</url>
      
        <content type="html"><![CDATA[<h1 id="技术博客"><a href="#技术博客" class="headerlink" title="技术博客"></a>技术博客</h1><h3 id="如何拉取本地不存在的分支"><a href="#如何拉取本地不存在的分支" class="headerlink" title="如何拉取本地不存在的分支"></a>如何拉取本地不存在的分支</h3><ol><li>在远程库创建分支，新建个文件，提交</li><li>git  branch -a  查看所有分支</li><li>执行git  pull  或者git  fetch</li><li>执行git checkout -b  本地分支    origin/远程分支</li></ol><h3 id="删除分支的几种方法"><a href="#删除分支的几种方法" class="headerlink" title="删除分支的几种方法"></a>删除分支的几种方法</h3><ol><li>git  branch  -d   本地分支</li><li>git  branch  -dr  删除远程分支  （只能删除本地库和远程库分支之间的追踪关系）</li><li>git   push   origin –delete  远程分支     （彻底删除）</li><li>git  push   origin       :  远程分支 </li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>第八天啦</title>
      <link href="/2019/10/08/2019-08-21-eight/"/>
      <url>/2019/10/08/2019-08-21-eight/</url>
      
        <content type="html"><![CDATA[<h1 id="日报"><a href="#日报" class="headerlink" title="日报"></a>日报</h1><h1 id="第八天啦"><a href="#第八天啦" class="headerlink" title="第八天啦"></a>第八天啦</h1><h4 id="今天是进入兄弟会第一次进行技术分享，虽然开始出现了点状况，但丝毫不影响我发挥。就是这么帅！"><a href="#今天是进入兄弟会第一次进行技术分享，虽然开始出现了点状况，但丝毫不影响我发挥。就是这么帅！" class="headerlink" title="今天是进入兄弟会第一次进行技术分享，虽然开始出现了点状况，但丝毫不影响我发挥。就是这么帅！"></a>今天是进入兄弟会第一次进行技术分享，虽然开始出现了点状况，但丝毫不影响我发挥。就是这么帅！</h4><hr><ol><li>撤销暂存区中的文件<br>git checkout  文件名     </li><li>撤销本地区的内容到暂存区<br>git  commit   –atend  </li><li>撤销本地区的内容到版本前<br>git  revert   哈希值  </li></ol><hr><p><strong>今天状态还不错其实，每天毫无困意，就是想多学点东西，总感觉知识还是了解的不够。还要继续努力啊，学无止境，每天都要给自己加油！！</strong>  </p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>第七天啦</title>
      <link href="/2019/10/08/2019-08-20-seven/"/>
      <url>/2019/10/08/2019-08-20-seven/</url>
      
        <content type="html"><![CDATA[<h1 id="日报"><a href="#日报" class="headerlink" title="日报"></a>日报</h1><h2 id="第七天啦"><a href="#第七天啦" class="headerlink" title="第七天啦"></a>第七天啦</h2><hr><pre><code>今天继续玩git  这个git玩了四五天了，但是总感觉差点什么，自己记了笔记，总结了一下git的常用语法。  </code></pre><p><strong>奥对了，还帮助了佳兴弟弟解决了几个问题，感觉能帮助别人解决了问题，也是一种能力的体现，也是对自己的查验，找到自己的不足</strong></p><hr><p><img src="https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1566907794&di=0609fd383d6ea077bab33fd9d4429a9b&imgtype=jpg&er=1&src=http%3A%2F%2Fimg4.duitang.com%2Fuploads%2Fitem%2F201608%2F25%2F20160825145037_a5jmY.jpeg" alt></p><h4 id="加油，继续努力！！"><a href="#加油，继续努力！！" class="headerlink" title="加油，继续努力！！"></a>加油，继续努力！！</h4>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Branch</title>
      <link href="/2019/10/08/2019-08-19-Branch/"/>
      <url>/2019/10/08/2019-08-19-Branch/</url>
      
        <content type="html"><![CDATA[<h1 id="Github分支"><a href="#Github分支" class="headerlink" title="Github分支"></a>Github分支</h1><h1 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h1><ol><li>分支创建<br> git   branch   分支名</li><li>分支转换<br> git   checkout   分支名</li><li>查看分支名<br> git branch -v</li><li>分支推进<br> git   push   -u origin   分支名  </li><li>分支合并<br> 首先切换到要被合并的分支  <pre><code>git   merge   有新内容的分支名  </code></pre></li></ol><hr><pre><code>## 切记，合并之后一定要推进提交</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>MarkDown</title>
      <link href="/2019/10/08/2019-08-18-markdown/"/>
      <url>/2019/10/08/2019-08-18-markdown/</url>
      
        <content type="html"><![CDATA[<h1 id="MarkDown基本语法"><a href="#MarkDown基本语法" class="headerlink" title="MarkDown基本语法"></a>MarkDown基本语法</h1><p><img src="/image/123456.png" alt="123"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Git语法</title>
      <link href="/2019/10/08/2019-08-17-GIT(%E5%A4%8D%E4%BB%B6)/"/>
      <url>/2019/10/08/2019-08-17-GIT(%E5%A4%8D%E4%BB%B6)/</url>
      
        <content type="html"><![CDATA[<h1 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h1><p>// 1. 创建版本库</p><p>$ cd:e // 切换盘符</p><p>$ cd .. // 回到文件上一层(注: cd与..中间有个空格)</p><p>$ cd ~ // 回到当前目录的主目录</p><p>$ mkdir Git // 创建文件夹Git</p><p>$ touch fileName // 新建文件</p><p>$ vi fileName // 编辑文件</p><p>$ press i button // 开始进入编辑状态</p><p>$ press the Esc button // 退出vim编辑区</p><p>$ :wq // 退出编辑状态, 回到命令窗口</p><p>$ mkdir learngit // 创建文件夹learngit </p><p>$ pwd // 显示当前路径/e/Git/learngit</p><p>$ git init // 将当前目录变成一个Git可以管理的仓库</p><p>$ touch+文件名 // 直接新建一个文件</p><p>$ git add readme.txt // 将文件添加到Git仓库（把文件修改添加到暂存区）</p><p>$ git commit -m “wrote a readme.txt.” // 将文件提交到仓库（把暂存区的所有内容提交到当前分支）</p><p>$ git add file1.txt // 添加file1.txt文件</p><p>$ git add file2.txt file3.txt // 同时添加file2.txt和file3.txt两个文件</p><p>$ git commit -m “add 3 files.” // 一次性提交3个文件</p><ol start="2"><li>时光穿梭机：</li></ol><p>// 2.1 版本回退</p><p>$ git status // 查看当前仓库状态（仓库下的工作区文件是否被修改过）</p><p>$ git diff readme.txt // 查看工作区的readme.txt与缓存区的readme.txt的区别</p><p>$ git log // 查看最近到最远的提交记录（详情: commit id + Author + Date + comment）</p><p>$ git log –pretty=oneline // 查看最近到最远的提交记录（简写：commit id + comment）</p><p>$ git reset –hard HEAD^ // 回到上一个版本（HEAD: 当前版本，HEAD^: 上一个版本，HEAD~100: 往上100个版本）</p><p>$ git reset –hard 1234567 // 回到指定版本号commit id（此处：commit id 假设为1234567<strong>**</strong>，Git会根据commit id的前几位自动寻找对应的版本）</p><p>$ cat readme.txt // 查看readme.txt的内容</p><p>$ git reflog // 查看每一次命令记录历史，确保能回到任意版本　　</p><p>// 2.2 工作区与暂存区</p><p>$ git diff readme.txt // 比较工作区（working directory）和暂存区（stage/index）的区别</p><p>$ git diff –cached // 比较暂存区（stage/index）和分支（master）的区别</p><p>// 2.3 管理修改（详见1. 创建版本库中的命令）</p><p>// 2.4 撤销修改</p><p>$ git checkout – readme.txt // 撤销修改：1. 文件在添加到缓存区前修改，则回退到原工作区状态；2. 文件在添加到缓存区后修改，则回退到原缓存区状态。也即是将readme.txt撤回到最近一次git add或git commit状态（注：–表示在当前分支，如果没有，则切换到另一个分支）</p><p>$ cat readme.txt // 查看文件内容</p><p>$ git reset HEAD readme.txt // 1. 回退到最新版本；2. 将暂存区的修改回退到工作区</p><p>// 2.5 删除文件</p><p>$ rm test.txt // 删除工作区文件（类似于手动删除）</p><p>$ git status // 查看当前工作区与缓存区状态</p><p>$ git rm test.txt // 情况1：确认删除</p><p>$ git commit -m “remove test.txt” // 情况1：确认删除后，提交到版本库</p><p>$ git checkout – readme.txt // 情况2：误删，需要回退（即：用版本库里的版本替换工作区的版本）</p><p>// 3. 远程仓库</p><p>// 3.1 添加远程库</p><p>git remote add origin git@server-name:path/repo-name.git // 关联一个远程仓库，如：$ git remote add origin <a href="mailto:git@github.com" target="_blank" rel="noopener">git@github.com</a>:ChrisLeejing/learngit.git</p><p>git push -u origin master // 第一次推送master分支的所有内容</p><p>注：在GitHub上创建新仓库时，如果勾选了README.md选项时，可能会出现下面错误，提示：远程仓库有readme.txt,而本地仓库没有README.txt,此时应该先进行合并文件，再进行推送。</p><p>git pull –rebase origin master // 推送之前，进行合并</p><p>合并文件之后，发现本地仓库中多了README.md文件，此时再进行推送修改到远程仓库就可以了。</p><p>再次执行：git push -u origin master, 即可推送本地仓库到远程仓库了</p><p>查看GitHub上的文件，已经更新！</p><p>git push origin master // 以后每次本地修改更新后，推送最新修改</p><p>// 3.2 从远程库克隆</p><p>$ git clone <a href="mailto:git@github.com" target="_blank" rel="noopener">git@github.com</a>:ChrisLeejing/gitskills.git // 以SSH方式克隆</p><p>$ git clone <a href="https://github.com/ChrisLeejing/gitskills.git" target="_blank" rel="noopener">https://github.com/ChrisLeejing/gitskills.git</a> // 以Https协议方式克隆</p><p>// 4. 分支管理</p><p>// 4.1 创建与合并分支</p><p>git branch // 查看所有分支（当前分支以‘*’标记）</p><p>git branch <name> // 创建分支（如：git branch dev）</name></p><p>git checkout <name> // 切换分支</name></p><p>git checkout -b <name> // 创建切换分支（如：git checkout -b dev）</name></p><p>git merge <name> // 合并分支到当前分支上</name></p><p>git branch -d <name> // 删除该分支</name></p><p>// 4.2 解决冲突</p><p>git log –graph // 查看分支合并图</p><p>git log –graph –pretty=oneline –abbrev-commit // 查看分支合并缩略图</p><p>// 4.3 分支管理策略</p><p>git merge –no-ff -m “注释” dev // 合并后的分支有历史记录，而Fast-Forward合并之后，分支没有历史记录</p><p>// 4.4 Bug分支</p><p>git stash // 隐藏分支工作现场，为修复bug准备</p><p>git stash list // 查看有哪些分支隐藏的工作现场，为恢复工作现场做准备</p><p>git stash apply // 恢复工作现场，但不删除存储的stash内容，结合git stash drop进行删除</p><p>git stash drop // 删除存储的stash内容，恢复到隐藏前的工作现场</p><p>git stash pop // 恢复到隐藏前的工作现场，相当于git stash apply和git stash drop</p><p>git stash apply stash@{0} // 可以多次stash，通过git stash list查看所有的stash，然后可以恢复到指定的隐藏的工作现场</p><p>// 4.5 Feature分支</p><p>注：当添加一个feature时，最好新建一个分支：git checkout -b <name></name></p><p>git branch -D <name> // 强行删除一个没有被合并到主分支的分支</name></p><p>// 4.6 多人协作（最好结合工作场景理解）</p><p>git remote -v // 查看远程库详细信息</p><p>git push origin dev // push本地dev分支到远程dev</p><p>git push origin master // push本地master分支到远程master（时刻保持同步）</p><p>git pull // 将最新的pull/dev(master)爬下来</p><p>git checkout -b branch-name origin/branch-name // 在本地创建和远程分支对应的分支</p><p>git branch –set-upstream-to=origin/<branch> dev // 建立本地分支和远程分支的关联</branch></p><p>// 4.7 Rebase</p><p>git rebase // 将本地未push的分支提交整理成直线，利于查看</p><p>// 5. 标签管理</p><p>// 5.1 创建标签</p><p>git tag <tagname> // 创建标签</tagname></p><p>git tag // 查看所有标签</p><p>git tag <tagname> commitId // 为某次提交创建指定标签</tagname></p><p>git show <tagname> // 查看指定标签具体内容</tagname></p><p>git tag -a <tagname> -m “v0.1 released” commitId // 为某次指定的提交创建标签，同时添加标签注释</tagname></p><p>git tag -d <tagname> // 删除某个标签</tagname></p><p>git push origin <tagname> // 推送某个标签到远程库</tagname></p><p>git push origin –tags // 一次性推送所有标签到远程库</p><p>git tag -d v0.9 // 删除远程库标签（第一步：删除本地库标签）</p><p>git push origin :refs/tags/v0.9 // 删除远程库标签（第二步：从远程库删除标签）</p><p>// 6. 使用GitHub</p><p>在GitHub上，可以自己fork任意开源仓库，自己拥有fork后的仓库的读与写操作权限，可以推送pull request给官方仓库贡献代码。</p><p>// 7. 使用码云（与GitHub类似，用到的时候，再注册使用练习，毕竟GitHub更加NB一些！）</p><p>// 8. 自定义Git（这里只是简单入门）</p><p>git config –global color.ui true // 让Git显示颜色</p><p>// 8.1 忽略特殊文件</p><p>忽略某些文件时，需要编写.gitignore文件，文件本身要放到版本库中，Git可以对.gitignore做版本管理！（注：不需要从头写.gitignore文件，GitHub已经为我们准备了各种配置文件，只需要组合一下就可以使用了。所有配置文件可以直接在线浏览：<a href="https://github.com/github/gitignore）" target="_blank" rel="noopener">https://github.com/github/gitignore）</a></p><p>// 8.2 配置别名</p><p>git config –global alias.st status // 将st作为status的别名，以后就可以git st查看暂存区与工作区的状态了（还有类似co:checkout, ci:commit, br:branch，–global:是针对于当前用户起作用的，如果不加，则只针对于当前仓库）</p><p>cat .gitignore // 查看当前文件所有配置信息（包括别名信息）</p><p>// 8.3 搭建Git服务器（暂时用不上，用的时候，再复习一下）</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>第四天啦</title>
      <link href="/2019/10/08/2019-08-17-four/"/>
      <url>/2019/10/08/2019-08-17-four/</url>
      
        <content type="html"><![CDATA[<h1 id="日报"><a href="#日报" class="headerlink" title="日报"></a>日报</h1><h1 id="第四天啦"><a href="#第四天啦" class="headerlink" title="第四天啦"></a>第四天啦</h1><ul><li><em>今天是进入兄弟会的第四天了，今天的进度和状态是最不好的，今天把博客又更新了一下主题，更换了头像，学到了很多东西，自己添加了图片，使内容更加丰满了，但还有很多的不足之处，日后再慢慢改进！</em></li></ul><hr><ul><li><strong>晚自习的时候，东哥给我们分享了“刻意练习”“一万个小时”的书，听了之后感触很多，没有天才，只是环境改变了他，你必须专注于某一件事，并且长时间去做，你一定会成功。</strong></li></ul><hr><h2 id="大量重复训练"><a href="#大量重复训练" class="headerlink" title="大量重复训练"></a>大量重复训练</h2><p>从不会到会，秘诀是重复。美国加州有个“害羞诊所”（The ShynessClinic），专门帮助那些比如说不敢和异性说话的人克服害羞心理。这个诊所的心理学家不相信什么心理暗示疗法，什么童年回忆之类，他们相信练习。他们认为使人害羞的并不是事情本身，而是我们对事情的观点。怎么治疗恐女症？做法是设计各种不同难度的场合，从在房间内集体对话到直接跑到大街上找陌生美女搭讪，安排接受治疗者在一个疗程之内跟130个女人聊过天。</p><p>这种把不常见的高难度事件重复化的办法正是MBA课程的精髓。在商学院里一个学生每周可能要面对20个真实发生过的商业案例，学生们首先自己研究怎么决策，提出解决方案，最后老师给出实际的结果并作点评。学习商业决策的最好办法不是观察老板每个月做两次决策，而是自己每周做20次模拟的决策。军事学院的模拟战，飞行员在计算机上模拟各种罕见的空中险情，包括丘吉尔对着镜子练习演讲，都是重复训练。</p><p>在体育和音乐训练中，比较强调“分块”练习。首先你要把整个动作或者整首曲子过一遍，看专家是怎么做的。然后把它分解为很多小块，一块一块地学习掌握。在这种训练中一定要慢，只有慢下来才能感知技能的内部结构，注意到自己的错误。在美国一所最好的小提琴学校里，甚至有禁止学生把一支曲子连贯地演奏的要求，规定如果别人听出来你拉的是什么曲子，那就说明你没有正确练习。职业的体育训练往往是针对技术动作，而不是比赛本身。一个高水平的美式足球运动员只有1%的时间用于队内比赛，其他都是各种相关的基础训练。</p><p>反过来说如果没有这种事先的重复训练，一个人面对不常见的事件往往会不知所措。统计表明工作多年的医生通过读X光片诊断罕见病症的水平反而不如刚毕业的医学院学生—因为很少遇到这种病例，而在医学院学到的东西早就忘了。最好的办法其实是定期地让医生们拿过去的旧X光片集中训练，而不是期待在工作中碰到。</p><h2 id="持续获得有效的反馈"><a href="#持续获得有效的反馈" class="headerlink" title="持续获得有效的反馈"></a>持续获得有效的反馈</h2><p>传道，授业，解惑，老师和教练最大的用处是什么？也许对一般人来说小学老师最大的作用是激发了他学习的兴趣，教会了他什么东西，曾经有过传道授业解惑。而真正的高手都有很强的自学能力，对他们而言，老师和教练的最重要作用是提供即时的反馈。</p><p>一个动作做得好与不好，最好有教练随时指出，本人必须能够随时了解练习结果。看不到结果的练习等于没有练习：如果只是应付了事，你不但不会变好，而且会对好坏不再关心。在某种程度上，刻意练习是以错误为中心的练习。练习者必须建立起对错误的极度敏感，一旦发现自己错了会感到非常不舒服，一直练习到改正为止。</p><p>从训练的角度，一个真正好教练是什么样的？John Wooden 是美国最具传奇色彩的大学篮球教练，他曾经率领 UCLA 队在12年内10次获得 NCAA 冠军。为了获得 Wooden的执教秘诀，两位心理学家曾经全程观察他的训练课，甚至记录下了他给球员的每一条指令。结果统计表明，在记录的2326条指令之中, 6.9%是表扬，6.6%是表示不满，而有75% 是纯粹的信息，也就是做什么动作和怎么做。他最常见的办法是三段论：演示一遍正确动作，表现一遍错误动作，再演示一遍正确动作。</p><p>与外行想象的不同，最好的教练从不发表什么激情演说，甚至不讲课，说话从不超过20秒。他们只给学生非常具体的即时反馈。所有训练都事先进行无比详细的计划，甚至包括教运动员怎么系鞋带。他们仿佛有一种诡异的知道学员在想什么的能力，即使是第一次见面能指出学生在技术上最需要什么。他们是绝对的因材施教，源源不断地提供高度具有针对性的具体指导。</p><p>获得反馈的最高境界是自己给自己当教练。高手工作的时候会以一个旁观者的角度观察自己，每天都有非常具体的小目标，对自己的错误极其敏感，并不断寻求改进。</p><h2 id="精神高度集中"><a href="#精神高度集中" class="headerlink" title="精神高度集中"></a>精神高度集中</h2><p>刻意练习没有“寓教于乐”这个概念。曾经有个著名小提琴家说过，如果你是练习手指，你可以练一整天；可是如果你是练习脑子，你每天能练两个小时就不错了。高手的练习每次最多1到1.5小时，每天最多4到5小时。没人受得了更多。一般女球迷可能认为贝克汉姆那样的球星很可爱，她们可能不知道的是很少有球员能完成贝克汉姆的训练强度，因为太苦了。<br>科学家们曾经调查研究了一个音乐学院。他们把这里的所有小提琴学生分为好（将来主要是做音乐教师），更好，和最好（将来做演奏家）三个组。这三个组的学生在很多方面都相同，比如都是从8岁左右开始练习，甚至现在每周的总的音乐相关活动（上课，学习，练习）时间也相同，都是51个小时。</p><p>研究人员发现，所有学生都了解一个道理：真正决定你水平的不是全班一起上的音乐课，而是单独练习：<br>－最好的两个组学生平均每周有24小时的单独练习，而第三个组只有9小时。<br>－他们都认为单独练习是最困难也是最不好玩的活动。<br>－最好的两个组的学生利用上午的晚些时候和下午的早些时候单独练习，这时候他们还很清醒；而第三个组利用下午的晚些时候单独练习，这时候他们已经很困了。<br>－最好的两个组不仅仅练得多，而且睡眠也多。他们午睡也多。<br>那么是什么因素区分了前两个组呢？是学生的历史练习总时间。到18岁，最好的组中，学会平均总共练习了7410小时，而第二组是 5301小时，第三组 3420小时。第二组的人现在跟最好的组一样努力，可是已经晚了。可见要想成为世界级高手，一定要尽早投入训练，这就是为什么天才音乐家都是从很小的时候就开始苦练了。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>第三天</title>
      <link href="/2019/10/08/2019-08-16-Three/"/>
      <url>/2019/10/08/2019-08-16-Three/</url>
      
        <content type="html"><![CDATA[<h1 id="日报"><a href="#日报" class="headerlink" title="日报"></a>日报</h1><h1 id="第三天啦"><a href="#第三天啦" class="headerlink" title="第三天啦"></a>第三天啦</h1><hr><p><strong>今天有点不顺，昨天做的博客太简单了，所以今天换了一个模板，真的是要炸了</strong></p><p><em>我终于会插入图片了！！！折磨我一下午啊，如释重负的感觉，很棒</em></p><h2 id="终于完善了一个属于自己的博客！！"><a href="#终于完善了一个属于自己的博客！！" class="headerlink" title="###终于完善了一个属于自己的博客！！"></a>###终于完善了一个属于自己的博客！！</h2><p><em>加油加油！今天还要把git语句熟悉一遍</em></p><h2 id="情绪一定要控制好，按时吃饭，按时睡觉，先谋生，再谋爱。"><a href="#情绪一定要控制好，按时吃饭，按时睡觉，先谋生，再谋爱。" class="headerlink" title=" 情绪一定要控制好，按时吃饭，按时睡觉，先谋生，再谋爱。"></a> <em>情绪一定要控制好，按时吃饭，按时睡觉，先谋生，再谋爱。</em></h2><hr><h2 id="为自己鼓掌！！！"><a href="#为自己鼓掌！！！" class="headerlink" title="为自己鼓掌！！！"></a>为自己鼓掌！！！</h2><pre><code></code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Git基本语法</title>
      <link href="/2019/10/08/2019-08-16-GIT/"/>
      <url>/2019/10/08/2019-08-16-GIT/</url>
      
        <content type="html"><![CDATA[<h1 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h1><p>#1.查看版本状态<br>命令:<br>git status 查看当前版本库的状态 git diff 查看当前相对上一次提交修改的内容</p><p>#2.版本回退</p><p>命令: git log<br>显示从最近到最远的提交日志 git log –pretty== oneline 显示log,但是不显示很多凌乱的信息 q 显示log版本信息有很多，使用q键停止查看 git reset —hard head^ 回退到上一个版本 git reset —hard head^^ 回退到上上个版本 git reset —hard head~100 回退到之前100个版本 git reset —hard +commit_id 回到某个版本号的版本</p><p>问题说明：版本回退过多，想仍然使用被回退掉的最新版本 情况一：曾经查看过log, 当前的命令窗口并未关闭，找到原来的版本号，使用如下命令恢复： git reset — hard 版本号</p><p>情况二：命令行已经关闭，不知道原来的版本号。使用git reflog查看曾经使用过的命令，曾经回退版本的时候会在这里显示版本号，然后继续使用情况一中的方法，恢复版本。</p><p>小结： 使用git log 我们可以看到一大串的commit id(版本号), 这不同于SVN的版本号(递增的数字),Git的版本号是SHA1计算出来的一个非常大的数字，防止分布式系统开发版本号冲突。</p><p>3.工作区与暂存区 工作区是我们在电脑里看到的目录，比如一个文件夹。工作区有一个隐藏目录.git，这个是Git的版本库。Git版本库里存很多东西，最重要的是暂存区(stage或者index)。Git为我们自动创建第一个分支master,以及master的一个指针叫做HEAD。 git add : 添加文件，是将文件修改添加到暂存区。 git commit : 提交更改，实际是把暂存区的所有内容提交到当前分支 一但提交之后，如果你又没有对工作区有新的修改，那么工作区是clean的</p><p>4.管理修改</p><p>问题说明: 我们修改一个文件，第一次修改之后执行git add ，第二次修改不执行git add ,然后我们执行git commit并使用git status查看状态，可以发现第二次的修改并未提交。这是因为Git跟踪修改，如果不add到暂存区就不会加入到commit。 解决方案：继续执行git add，再git commit，也可以别着急提交第一次修改，先add第二次修改再commit</p><p>5.撤销修改 情况一: 文件修改后还没被放到暂存区， 情况二: 文件修改后已经被添加到暂存区，然后又做了修改。又修改部分被撤销， 解决方案： git checkout – + 文件名 将文件在工作区的修改全部撤销。 执行结果: 情况一：执行撤销就回到和版本库一模一样的状态。 情况二：文件会恢复到上次添加到暂存区的状态，即使多次使用也只能回到最近一次暂存区状态。 情况一和情况二，总之都是让文件回到最近一次git commit或者add时的状态</p><p>情况三：想要撤销的部分已经add到暂存区，但是还没有被commit</p><p>解决方案： 1.使用git reset HEAD +文件名 把暂存区的修改撤销，重新放回到工作区。 2.根据情况1和情况2的方法撤销修改</p><p>情况四：想要撤销的部分已经提交到版本库中，但是还没有push到远程仓库 解决方法：使版本回退的方法</p><p>小结：git check的 “—” 很重要，没有“—“, 该命令就变成了切换分支的命令(双横杠)</p><p>6.删除文件 命令： rm + 文件名 删除文件</p><p>分析问题： 修改一个文件，使用add、commit将其添加到版本库中，然后又在文件管理器中删除了此文件。这时就会使工作区和版本库不一致了。 git status会告诉那些文件被删除。这时候处理方法有两种： 选择1： 确实要从版本库中删除该文件，使用git rm +文件名 然后commit, 文件就从版本库中删除了 选择2： 其实是删错了。因为版本库中还有，可以将误删文件恢复到最新版本, 但是最近一次提交之后修改的内容丢失了。这里使用的命令是： git check – +文件名</p><p>小结：git checkout 其实是使用版本库中版本替换工作区版本，无论修改还是删除都可以”一键还原” 五、远程仓库 1.本地仓库与远程仓库之间的传输设置 本地仓库Git仓库和GitHub仓库之间的传输是通过SSH加密的，所以需要一点设置：</p><p>第一步：创建SSH Key。 1.在用户的主目录下，查看是否有.ssh目录. 2.如果有，再看看这个目录有没有 id_rsa和id_rsa.pub这两个文件。 3.如果有，可直接跳到下一步。 4.如果没有，打开Shell(Window下打开Git Bash),创建SSH Key。 5.使用命令创建SSH Key： ssh -keygen -t rss -C + github邮箱地址</p><p>第二步：设置远程仓库的key(以GitHub为例) 1.登陆GitHub，打开“Account Setting” -&gt;“SSH Keys”页面。 2.点击”Add SSH Key”, 填上任意Title, 在key文本框中粘贴id_rsa.pub文件的内容。 3.点击”Add key”，确认添加了公钥</p><p>小结：</p><p>1.id_rsa是私钥，不能泄露出去；id_rsa.public是公钥，可以放心的告诉任何人。</p><p>2.GitHub通过SSH Key加密，是为了识别是否为真用户的提交。</p><p>3.GitHub允许添加多个key,将多台电脑的Key添加到GitHub，就可以在每台电脑上推送了</p><p>4.创建key的时候，key并不是很重要，可以不设置密码</p><p>2.将本地仓库与远程仓库关联同步 命令: git remote add origin +远程仓库地址 将本地仓库关联远程仓库 git push -u origin master 第一次推送master分支的所有内容到远程仓库 git push origin master 本地推送到远程(第一次之后）</p><p>小结: 要关联一个远程仓库，使用命令 “git remote add origin + 远程仓库地址”， 关联之后使用命令 “git push -u origin master” 第一次推送master分支的所有内容。 每次本地提交之后，只要有必要就可以使用命令git push origin master推送最新修改。</p><p>3.从远程仓库克隆文件到本地 命令: git clone +远程仓库地址 克隆远程仓库到本地，相当于创建了与之关联的本地仓库</p><p>示例: 先使用cd命令切换到某个文件夹位置然后使用如下命令: git clone <a href="mailto:git@github.com" target="_blank" rel="noopener">git@github.com</a>:DreamcoffeeZS/Demo_FDTemplateLayoutCell.git</p><p>小结: 1.克隆仓库，首先要知道仓库地址(查看GitHub)，然后使用git clone命令克隆。 2.Git支持多种协议，包括https，但是通过ssh支持的原生git协议速度更快。 3.执行该命令成功后，本地就会出现于远程仓库相关联的本地仓库，可以track远程仓库的变化</p><p>六、分支管理 1.理解概念： a. 主分支(默认分支)，代表版本commit的形成的时间线 b. HEAD指针指向master分支，master指针指向版本库commit的最新位置 c. 每次commit，master指针会向前移动一步，随着不断提交，master分支线越来越长。 d. 每次创建新的分支，如dev分支，Git会创建新的分支指针dev，然后将dev指针指向与master指针相同的提交位置，再将HEAD指针指向dev，表明当前分支是dev。 e. 合并分支其实就是改变原来分支指针的指向。合并之后可以删除无用的分支</p><p>2.创建与合并分支 命令: git checkout + 分支名 切换分支 git checkout -b dev git checkout命令加上-b参数表示创建并切换分支 git branch 查看当前分支,会显示所有分支，并在当前分支前加*号 git merge + 分支名 合并分支，指定分支名的分支合并到当前分支。 git branch + 分支名 创建分支 git branch -d + 分支名 删除指定分支名的分支</p><p>小结： 1.Git创建、合并、删除分支都非常快，因为只是改变了指针的位置。 2.Git鼓励使用分支完成某个任务，合并分支后再删掉分支，这和直接在master分支上工作一样，但是更安全。 3.解决分支冲突 问题说明： 在dev分支和master分支上修改同一个地方的内容，并且在各自分支上commit。然后在将dev分支合并到master分支时，会发生冲突。</p><p>问题分析: 1.发生冲突的时候，使用git status 可查看哪些冲突文件 2.Git用 &lt;&lt;&lt;&lt;&lt;&lt;&lt;，=======，&gt;&gt;&gt;&gt;&gt;&gt;&gt;在冲突文件中标记记出不同分支的内容。 解决方案: 1.在文件冲突的位置，取舍不同分支的修改，确定最终结果。然后执行add和commit。 2.然后用带参数的git log 可以查看分支合并情况，如： git log – graph – pretty==online –abbrev-commit 3.最后是删除dev分支</p><p>小结：git log – graph 命令可以查看分支合并图 4.分支管理策略 问题说明： 对于分支合并，通常的情况我们直接使用git merge命令进行合并，这些都是Fast Forward模式的快速合并。这种合并的缺点在于删除分支之后会丢失分支的信息。 问题分析： 强制禁用Fast forward 模式的合并。Git会在merge时生成一个新的commit，这样从分支历史就可以看出分支信息，禁用时需要使用—- no-ff参数。 示例说明： 在执行合并时的禁用Fast forward的一个示例如下： git merge –no-ff -m “合并分支生成新的commit” dev</p><p>分支策略： 在实际开发中，我们需要遵循的几个基本原则 1.master分支应该是稳定的，仅用来发布版本，平时不能在上面干活 2.dev分支是我们工作的分支，dev分支不稳定，在版本发布时再将dev分支合并到master分支 3.开发期间每个人都在dev分支上干活，每个人都有自己的分支，时不时的往dev分支合并就好了</p><p>5.Bug分支之stash 问题说明： 当前正在dev分支上工作，工作未完无法提交，但是又出现十分紧急的bug需要解决。可以使用stash功能，将当前的工作现场“储藏”起来。等以后恢复现在后继续工作。 命令: git stash 将当前的工作现场“储藏”起来，此时查看status， 工作区是干净的，可以放心创建分支修改bug git stash list 查看当前储藏区列表 git stash apply 恢复储藏区，但是stash内容并不删除 git stash drop 删除储藏区内容 git stash pop 恢复储藏区内容并删除内容，再使用git stash list不能看到删除的stash git stash apply stash@{0} 多次stash，恢复时候，先用git stash list查看编号，再执行stash恢复</p><p>小结： 1.修复bug时，我们会通过创建新的bug分支进行修复，然后合并，最后删除； 2.当手头工作没有完成时，先把工作现场git stash一下，然后去修复bug，修复后，再git stash pop，回到工作现场。 6.Feature分支 问题说明： 添加一个新功能时，你肯定不希望因为一些实验性质的代码，把主分支搞乱了，所以，每添加一个新功能，最好新建一个feature分支，在上面开发，完成后，合并，最后，删除该feature分支。 如果需要丢弃一个没有被合并的分支，我们可以强行删除 命令：git branch -D &lt;分支名&gt; 强制删除分支</p><p>7.多人协作 理解概念：从远程仓库克隆，实际上Git自动把本地master分支和远程master分支对应起来，并且远程仓库名默认是origin 命令: git remote 查看远程仓库信息 git remote -v 查看远程仓库更详细信息; 显示了可以抓取和推送的origin地址，无推送权限时看不到push地址 git push origin master 推送分支: 将本地master分支推送到对应的远程master分支上 git push origin dev 推送分支: 将本地dev分支推送到对应的远程dev分支上 git checkout -b +分支名 origin/分支名 在本地创建和远程分支对应的分支 git pull 把当前分支对应的远程分支上的内容拉取下来 git branch —-set-upstream +分支名 origin/分支名 建立本地分支和远程分支的关联</p><p>操作说明: 1.master分支是主分支，会因此要时刻与远程同步 2.dev分支是开发分支，团队所有成员都需要在上面工作，所以也要与远程同步 3.bug分支只用于本地修复bug，没必要推送远程，除非老板需要看你每周到底修改了几个bug 4.feature分支是否推送到远程，取决于你是否和同事合作在上面开发 5.多人协作开发时，大家会在master和dev分支上推送各自的修改 6.在本地创建和远程分支对应的分支，使用git checkout -b branch-name origin/branch-name，本地和远程分支的名称最好一致； 7.从远程抓取分支，使用git pull，如果有冲突，要先处理冲突。 小结： 1.协作开发时，两个人修改的同一个文件，各自从本地推送可能会提示冲突。解决方法是，先git pull,再把最新的提交从origin/dev抓下来，然后在本地合并，解决冲突，再推送。 2.在dev分支上开发，就必须创建远程origin的dev分支到本地 3.如果pull失败，说明没有指定本地的dev分支与远程分支origin/dev分支链接，根据提示，设置dev和origin/dev的链接关系： git branch —-set-upstream dev origin/dev ,然后再次pull</p><p>七、标签管理 理解标签: 1.Git的标签是版本库的快照，实际上是指向某个commit的指针，只不过它不想分支指针那样可以移动。 2.标签的作用是帮助我们快速的找到某个时候的版本，常用于开发到每个阶段时设置的开发版本标签(tag)。 命令： git tag + &lt;tag名&gt; 创建一个标签 git tag 查看所有标签 git tag + &lt;tag名&gt; + commitID 通过git log查看提交过的版本Id,可以为曾经某个commit时刻的版本打上标签 git show + 查看标签信息，可以看到tag的说明（如果创建的时候带有说明），可以看到PGP签名信息 git tag -a + -m + 创建带有说明的标签，用-a指定标签名，-m指定说明文字 git tag -s + -m + 通过-s用私钥签名一个标签，使用PGP签名，不过必须安装gpg(GunPG)，没有gpg秘钥对会报错 git tag -d + 删除标签 git push origin + 推送某个标签到远程 git push origin – tags 一次性推送全部尚未推送到远程的本地标签 git push origin :refs/tags/ 删除一个远程标签，登陆远程可查看删除标签效果。</p><p>示例：删除已经推送到远程的的标签，需要首先删除本地标签，然后从远程删除，使用 git push origin :refs/tags/标签名</p><p>小结： 1.默认标签是打在最新提交的commit上的 2.查看标签列表时，标签不是按照时间顺序列出的。 3.创建标签都会只存储到本地，不会自动推送到远程，所以打错的标签可以在本地安全删除 八.使用GItHub 1.在GitHub上，可以任意的Fork开源仓库，相当于是拷贝到自己远程仓库中 2.我们拥有的Fork后仓库的读写权限 3.可以推送pull request给官方仓库来贡献代码 九.自定义Git 1.忽略特殊文件 在我们使用Git的时候，有时候某些文件不得不放在git目录下，但是它们又不能被提交(可能是一些程序执行生成的中间文件)。这时候需要用到忽略文件。 原理：编辑.gitignore文件，将其放在版本库里并提交到Git。.gitignore文件中记录需要忽略提交的文件类型。 我们无需自己从头编写.gitignore文件，查看Github已经为我们准备好的配置文件，再根据自己的需要修改忽略文件即可。 2.配置别名 通过对一些复杂的命令指定别名，可以更加方便的使用Git git config – global alias.st status 指定别名：查看版本状态 git config – global alias.ci commit 指定别名：提交版本库 git config – global alias.co checkout 指定别名：切换分支 git config – global alias.br branch 指定别名：查看分支 git config – global alias.last ‘log -1’ 指定别名：显示最后一次提交信息</p><p>示例：设置别名后可以直接使用git st 查看当前版本状态</p><p>补充：git config –global alias.lg “log –color –graph –pretty=format: ‘%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset’ –abbrev-commit” 查看详细log</p><p>参数说明： – global 1.该参数是全局参数，配置Git的时候，加上–global是针对当前用户起作用，如果不加就只对当前的仓库起作用。 2.配置的别名被保存在配置文件中，每个仓库的git配置文件都放在.git/config文件中，别名就在[alias]后面，要删除别名，直接把对应的行删掉即可。 3.当前用户的Git配置文件放在用户主目录下的一个隐藏文件.gitconfig中： //查看配置文件的命令 cat .git/config 查看当前仓库的Git配置文件 cat .gitconfig 查看当前用户主目录下隐藏的配置文件</p><p>作者：梧雨北辰 链接：<a href="https://www.jianshu.com/p/9b040c70d4db" target="_blank" rel="noopener">https://www.jianshu.com/p/9b040c70d4db</a> 来源：简书 简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>第二天啦</title>
      <link href="/2019/10/08/2019-08-15-second/"/>
      <url>/2019/10/08/2019-08-15-second/</url>
      
        <content type="html"><![CDATA[<h1 id="Github"><a href="#Github" class="headerlink" title="Github"></a>Github</h1><p>　今天是进入兄弟会的第二天了，一天从早到晚一直坐在电脑面前。<br>今天独自学习了ｇｉｔｈｕｂ和ｇｉｔ语句，真的很神奇，你要是坚持下来，<br>就可以解决所有的问题，静下心来，努力学习，一天比一天优秀。加油！</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Git</title>
      <link href="/2019/10/08/2019-08-15-Git/"/>
      <url>/2019/10/08/2019-08-15-Git/</url>
      
        <content type="html"><![CDATA[<h1 id="Github"><a href="#Github" class="headerlink" title="Github"></a>Github</h1><p>mkdir 123<br>cd 123<br>git init<br>git add .<br>git commit -m “”<br>git remote add origin /<br>git  push origin master</p><p> ##yangxin@yangxin-GK5S:~$ cd yangxin19970404.github.io</p><p>yangxin@yangxin-GK5S:~/yangxin19970404.github.io$ git add –all</p><p>yangxin@yangxin-GK5S:~/yangxin19970404.github.io$ git commit -m “commit”</p><p>[master 58ae19c] commit</p><p> 3 files changed, 14 insertions(+), 13 deletions(-)</p><p> rename _posts/{2017-07-19-highlight-test.md =&gt; 2017-07-22-highlight-test.md} (100%)</p><p> delete mode 100644 “_posts/2018-07-20-diyitian(\345\244\215\344\273\266).md”</p><p> create mode 100644 “_posts/2055-1231-\344\270\273\351\241\265.md”</p><p>yangxin@yangxin-GK5S:~/yangxin19970404.github.io$ git push origin master</p><p>Username for ‘<a href="https://github.com&#39;" target="_blank" rel="noopener">https://github.com&#39;</a>: yangxin19970404</p><p>Password for ‘<a href="https://yangxin19970404@github.com&#39;" target="_blank" rel="noopener">https://yangxin19970404@github.com&#39;</a>: </p><p>对象计数中: 4, 完成.</p><p>Delta compression using up to 12 threads.</p><p>压缩对象中: 100% (4/4), 完成.</p><p>写入对象中: 100% (4/4), 542 bytes | 542.00 KiB/s, 完成.</p><p>Total 4 (delta 2), reused 0 (delta 0)</p><p>remote: Resolving deltas: 100% (2/2), completed with 2 local objects.</p><p>To <a href="https://github.com/yangxin19970404/yangxin19970404.github.io" target="_blank" rel="noopener">https://github.com/yangxin19970404/yangxin19970404.github.io</a></p><p>   3626600..58ae19c  master -&gt; master</p><p>yangxin@yangxin-GK5S:~/yangxin19970404.github.io$ ^C</p><p>yangxin@yangxin-GK5S:~/yangxin19970404.github.io$ </p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux</title>
      <link href="/2019/10/08/2019-08-14-Linux/"/>
      <url>/2019/10/08/2019-08-14-Linux/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h1><p>简介编辑<br>Linux是一套免费使用和自由传播的类Unix操作系统，是一个基于POSIX和Unix的多用户、多任务、支持多线程和多CPU的操作系统。伴随着互联网的发展，Linux得到了来自全世界软件爱好者、组织、公司的支持。它除了在服务器操作系统方面保持着强劲的发展势头以外，在个人电脑、嵌入式系统上都有着长足的进步。使用者不仅可以直观地获取该操作系统的实现机制，而且可以根据自身的需要来修改完善这个操作系统，使其最大化地适应用户的需要。 [1]<br>Linux不仅系统性能稳定，而且是开源软件。其核心防火墙组件性能高效、配置简单，保证了系统的安全。在很多企业网络中，为了追求速度和安全，Linux操作系统不仅仅是被网络运维人员当作服务器使用，Linux既可以当作服务器，又可以当作网络防火墙是Linux的 一大亮点。 [2]<br>Linux与其他操作系统相比 ，具有开放源码、没有版权、技术社区用户多等特点 ，开放源码使得用户可以自由裁剪，灵活性高，功能强大，成本低。尤其系统中内嵌网络协议栈 ，经过适当的配置就可实现路由器的功能。这些特点使得Linux成为开发路由交换设备的理想开发平台。 [3]<br>Linux简史编辑<br>Linux操作系统的诞生、发展和成长过程始终依赖着五个重要支柱：Unix操作系统、MINIX操作系统、GNU计划、POSIX标准和Internet网络。<br>20世纪80年代，计算机硬件的性能不断提高，PC的市场不断扩大，当时可供计算机选用的操作系统主要有Unix、DOS和MacOS这几种。Unix价格昂贵，不能运行于PC；DOS显得简陋，且源代码被软件厂商严格保密；<br>　　MacOS是一种专门用于苹果计算机的操作系统。此时，计算机科学领域迫切需要一个更加完善、强大、廉价和完全开放的操作系统。由于供教学使用的典型操作系统很少，因此当时在荷兰当教授的美国人AndrewS.Tanenbaum编写了一个操作系统，名为MINIX，为了向学生讲述操作系统内部工作原理。MINIX虽然很好，但只是一个用于教学目的的简单操作系统，而不是一个强有力的实用操作系统，然而最大的好处就是公开源代码。全世界学计算机的学生都通过钻研MINIX源代码来了解电脑里运行的MINIX操作系统，芬兰赫尔辛基大学大学二年级的学生Linus Torvalds就是其中一个，在吸收了MINIX精华的基础上，Linus于1991年写出了属于自己的Linux操作系统，版本为Linux0.01，是Linux时代开始的标志。他利用Unix的核心，去除繁杂的核心程序，改写成适用于一般计算机的x86系统，并放在网络上供大家下载，1994年推出完整的核心Version1.0，至此，Linux逐渐成为功能完善、稳定的操作系统，并被广泛使用。 [1]<br>主要特性编辑<br>编辑<br>基本思想<br>Linux的基本思想有两点：第一，一切都是文件；第二，每个软件都有确定的用途。其中第一条详细来讲就是系统中的所有都归结为一个文件，包括命令、硬件和软件设备、操作系统、进程等等对于操作系统内核而言，都被视为拥有各自特性或类型的文件。至于说Linux是基于Unix的，很大程度上也是因为这两者的基本思想十分相近。<br>完全免费<br>Linux是一款免费的操作系统，用户可以通过网络或其他途径免费获得，并可以任意修改其源代码。这是其他的操作系统所做不到的。正是由于这一点，来自全世界的无数程序员参与了Linux的修改、编写工作，程序员可以根据自己的兴趣和灵感对其进行改变，这让Linux吸收了无数程序员的精华，不断壮大。<br>完全兼容POSIX1.0标准<br>这使得可以在Linux下通过相应的模拟器运行常见的DOS、Windows的程序。这为用户从Windows转到Linux奠定了基础。许多用户在考虑使用Linux时，就想到以前在Windows下常见的程序是否能正常运行，这一点就消除了他们的疑虑。<br>多用户、多任务<br>Linux支持多用户，各个用户对于自己的文件设备有自己特殊的权利，保证了各用户之间互不影响。多任务则是现在电脑最主要的一个特点，Linux可以使多个程序同时并独立地运行。<br>良好的界面<br>Linux同时具有字符界面和图形界面。在字符界面用户可以通过键盘输入相应的指令来进行操作。它同时也提供了类似Windows图形界面的X-Window系统，用户可以使用鼠标对其进行操作。在X-Window环境中就和在Windows中相似，可以说是一个Linux版的Windows。<br>支持多种平台<br>Linux可以运行在多种硬件平台上，如具有x86、680x0、SPARC、Alpha等处理器的平台。此外Linux还是一种嵌入式操作系统，可以运行在掌上电脑、机顶盒或游戏机上。2001年1月份发布的Linux 2.4版内核已经能够完全支持Intel64位芯片架构。同时Linux也支持多处理器技术。多个处理器同时工作，使系统性能大大提高。<br>优点编辑<br>1)Linux由众多微内核组成，其源代码完全开源；<br>2)Linux继承了Unix的特性，具有非常强大的网络功能，其支持所有的因特网协议，包括TCP/IPv4、 TCP/IPv6和链路层拓扑程序等，且可以利用Unix的网络特性开发成出新的协议栈；<br>3)Linux系统工具链完整，简单操作就可以配置出合适的开发环境，可以简化开发过程，减少开发中仿真工具的障碍，使系统具有较强的移植性；<br>常用命令及技巧编辑<br>一、 通用命令<br>1、date ：打印或者设置系统的日期和时间<br>2、 stty -a：可以查看或者打印控制字符(Ctrl-C、Ctrl-D、 Ctrl-Z等)<br>3、 passwd：用passwd -h查看<br>4、logout，login： 登录shell的登录和注销命令<br>5、 more， less， head tail： 显示或部分显示文件内容<br>　　6、 lp/lpstat/cancel， lpr/lpq/lprm： 打印文件<br>　　7、 chmod u+x：更改文件权限<br>8、 rm -fr dir：删除非空目录<br>9、cp -R dir：拷贝目录<br>10、 fg jobid ：可以将一个后台进程放到前台<br>　　11、 kill 的作用： send a signal to a process、 eg： kill -9 发送的是SIG_KILL信号，具体发送什么信号 可以通过 man kill 查看、<br>　　12、 ps 的用法， ps -e 或 ps -o pid，ppid，session，tpgid， comm (其中session显示的sessionid， tpgid显示前台进程组id， comm显示命令名称)<br>　　二 、ubuntu常用命令：<br>1、 dpkg： package manager for Debian<br>　　* 安装： dpkg -i package<br>　　* 卸载： dpkg -r package<br>　　* 卸载并删除配置文件： dpkg -P |–purge package<br>　　* 如果安装一个包时、说依赖某些库、 可以先 apt-get install somelib<br>　　* 查看软件包安装内容 ：dpkg -L package<br>　　* 查看文件由哪个软件包提供： dpkg -S filename<br>　　* 另外 dpkg还有 dselect和aptitude 两个frontend<br>　　2、 apt<br>　　* 安装： apt-get install packs<br>　　* 更新源：apt-get update</p><ul><li>升级系统：apt-get upgrade<br>　　* 智能升级、安装新软件包，删除废弃的软件包：apt-get dist-upgrade<br>　　* f –fix broken 修复依赖：apt-get -f install<br>　　* 自动删除无用的软件：apt-get autoremove<br>　　* 删除软件：apt-get remove packages<br>　　* 删除包并清除配置文件：apt-get remove package –purge<br>　　* 清除所以删除包的残余配置文件： dpkg -l |grep ^rc|awk ‘{print $2}’ |tr [“/n”] [“ “]|sudo xargs dpkg -P<br>　　* 安装软件时候包的临时存放目录 ： /var/cache/apt/archives<br>　　* 清除该目录： apt-get clean<br>　　* 清除该目录的旧版本的软件缓存： apt-get autoclean<br>　　* 查询软件some的依赖包： apt-cache depends some<br>　　* 查询软件some被哪些包依赖： apt-get rdepends some<br>　　* 搜索软件： apt-cache search name|regexp<br>　　* 查看软件包的作用：apt-cache show package<br>　　* 查看一个软件的编译依赖库： apt-cache showsrc packagename|grep Build-Depends<br>　　* 下载软件的源代码 ： apt-get source packagename (注： sources、list 中应该有 deb-src 源)<br>　　* 安装软件包源码的同时， 安装其编译环境 ：apt-get build-dep packagename (有deb-src源)<br>　　* 如何将本地光盘加入安装源列表： apt-cdrom add<br>　　3、 系统命令：<br>　　* 查看内核版本：uname -a<br>　　* 查看ubuntu 版本：cat /etc/issue<br>　　* 查看网卡状态 ：ethtool eth0<br>　　* 查看内存，cpu的信息：cat /proc/meminfo ; cat /proc/cpuinfo<br>　　* 打印文件系统空间使用情况：df -h<br>　　* 查看硬盘分区情况：fdisk<br>　　* 产看文件大小：du -h filename;<br>　　* 查看目录大小：du -hs dirname ; du -h dirname是查看目录下所有文件的大小<br>　　* 查看内存的使用：free -m/-g/-k<br>　　* 查看进程：ps -e 或ps -aux –&gt;显示用户<br>　　* 杀掉进程：kill pid<br>　　* 强制杀掉：killall -9 processname<br>　　4、 网络相关：<br>　　* 配置 ADSL： sudo pppoeconf<br>　　* ADSL手工拨号： sudo pon dsl-provider<br>　　* 激活 ADSL ： sudo /etc/ppp/pppoe_on_boot<br>　　* 断开 ADSL： sudo poff<br>　　* 根据IP查网卡地址： arping IP地址<br>　　* 产看本地网络信息（包括ip等）： ifconfig | ifconfig eth0<br>　　* 查看路由信息： netstat -r<br>　　* 关闭网卡： sudo ifconfig eth0 down<br>　　* 启用网卡： sudo ifconfig eth0 up<br>　　* 添加一个服务： sudo update-rc、d 服务名 defaults 99<br>　　* 删除一个服务： sudo update-rc、d 服务名 remove<br>　　* 临时重启一个服务： /etc/init、d/服务名 restart<br>　　* 临时关闭一个服务： /etc/init、d/服务名 stop<br>　　* 临时启动一个服务： /etc/init、d/服务名 start<br>　　* 控制台下显示中文： sudo apt-get install zhcon<br>　　* 查找某个文件： whereis filename 或 find 目录 -name 文件名<br>　　*通过ssh传输文件<br>　　5、 压缩：<br>　　*解压缩 a、tar、gz： tar zxvf a、tar、gz<br>　　*解压缩 a、tar、bz2： tar jxvf a、tar、bz2<br>　　*压缩aaa bbb目录为xxx、tar、gz： tar zcvf xxx、tar、gz aaa bbb<br>　　*压缩aaa bbb目录为xxx、tar、bz2： tar jcvf xxx、tar、bz2 aaa bbb<br>6、 Nautilus：<br>　　特殊 URI 地址<br>　　* computer：/// - 全部挂载的设备和网络<br>　　* network：/// - 浏览可用的网络<br>　　* burn：/// - 一个刻录 CDs/DVDs 的数据虚拟目录<br>　　* smb：/// - 可用的 windows/samba 网络资源<br>　　* x-nautilus-desktop：/// - 桌面项目和图标<br>　　* file：/// - 本地文件<br>　　* trash：/// - 本地回收站目录<br>　　* ftp：// - FTP 文件夹<br>　　* ssh：// - SSH 文件夹<br>　　* fonts：/// - 字体文件夹，可将字体文件拖到此处以完成安装<br>　　* themes：/// - 系统主题文件夹<br>7、补充部分：</li><li>查看本地所有的tpc，udp监听端口： netstat -tupln (t=tcp， u=udp， p=program， l=listen， n=numric)<br>　　* 通过man搜说相关命令： man -k keyword 、 eg： man -k user<br>　　* 或者用 apropos<br>　　* 统计文件所占用的实际磁盘空间： du (du - estimate file space usage)<br>　　* 统计文件中的字符，字节数： wc -c/-l/-w (wc - print the number of newlines， words， and bytes in files)<br>　　* 查看文件的内容： od -x/-c/ (od - dump files in octal and other formats)<br>　　查看文件的 Ascii 码形式： od -t c filename (其中统计信息最左边的是： 字节数)<br>　　* 查找命令所在文件的位置： which od 输出： /usr/bin/od<br>　　查看该文件由哪个包提供： dpkg -S /usr/bin/od 输出： coreutils： /usr/bin/od<br>　　再查看coreutils包的全部内容就知道了linux的核心命令： dpkg -L coreutils<br>　　* 快速粘贴：先在一个地方选中文字，在欲粘贴的地方按鼠标 中键 即可、<br>　　* 等效中键：a 、按下滑轮等效于中键、b、同时按下鼠标 左右键，等效于中键<br>　　* 快速重启X服务： 同时按下： Alt + Ctrl + Backspace 三个键、<br>　　* 打开”运行”窗口： 同时按下 Alt + F2 键<br>　　* 截屏：<br>a、全屏：直接按下 PrtScr 键<br>　　b、当前窗口：同时按下 Alt + PrtScr 键<br>　　c、延时截屏：在 终端 或 “运行”窗口中输入命令： gnome-screenshot –delay 3 ，将延时 3 秒后截屏、<br>8、ulimit<br>　　ulimit：显示（或设置）用户可以使用的资源的限制（limit），这限制分为软限制（当前限制）和硬限制（上限），其中硬限制是软限制的上限值，应用程序在运行过程中使用的系统资源不超过相应的软限制，任何的超越都导致进程的终止<br>　　ulimited 不限制用户可以使用的资源，但本设置对可打开的最大文件数（max open files）和可同时运行的最大进程数（max user processes）无效<br>　　-a 列出所有当前资源极限<br>　　-c 设置core文件的最大值、单位：blocks<br>　　-d 设置一个进程的数据段的最大值、单位：kbytes<br>　　-f Shell 创建文件的文件大小的最大值，单位：blocks<br>　　-h 指定设置某个给定资源的硬极限、如果用户拥有 root 用户权限，可以增大硬极限、任何用户均可减少硬极限<br>　　-l 可以锁住的物理内存的最大值<br>　　-m 可以使用的常驻内存的最大值，单位：kbytes<br>　　-n 每个进程可以同时打开的最大文件数<br>　　-p 设置管道的最大值，单位为block，1block=512bytes<br>　　-s 指定堆栈的最大值：单位：kbytes<br>　　-S 指定为给定的资源设置软极限、软极限可增大到硬极限的值、如果 -H 和 -S 标志均未指定，极限适用于以上二者<br>　　-t 指定每个进程所使用的秒数，单位：seconds<br>　　-u 可以运行的最大并发进程数<br>　　-v Shell可使用的最大的虚拟内存，单位：kbytes<br>　　eg： ulimit -c 1000(可以先通过ulimit -c 查看原来的值)</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>美女大图</title>
      <link href="/2019/10/08/2019-08-14-image/"/>
      <url>/2019/10/08/2019-08-14-image/</url>
      
        <content type="html"><![CDATA[<h1 id="江疏影"><a href="#江疏影" class="headerlink" title="江疏影"></a>江疏影</h1><p><img src="https://ss0.bdstatic.com/70cFuHSh_Q1YnxGkpoWK1HF6hhy/it/u=2270388199,2152945753&fm=26&gp=0.jpg" alt="avatar"></p><p><img src="https://ss1.bdstatic.com/70cFvXSh_Q1YnxGkpoWK1HF6hhy/it/u=3634044642,3139714349&fm=26&gp=0.jpg" alt="avatar"></p><p><img src="https://ss2.bdstatic.com/70cFvnSh_Q1YnxGkpoWK1HF6hhy/it/u=1747620305,2582509471&fm=26&gp=0.jpg" alt="avatar"></p><p><img src="https://ss0.bdstatic.com/70cFuHSh_Q1YnxGkpoWK1HF6hhy/it/u=479587150,480257166&fm=11&gp=0.jpg" alt="avatar"></p><hr>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>第一天啦</title>
      <link href="/2019/10/08/2019-08-14-first/"/>
      <url>/2019/10/08/2019-08-14-first/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux系统"><a href="#Linux系统" class="headerlink" title="Linux系统"></a>Linux系统</h1><h2 id="我叫杨鑫"><a href="#我叫杨鑫" class="headerlink" title="我叫杨鑫"></a><strong>我叫杨鑫</strong></h2><hr><p><em>很荣幸今天能够进入到兄弟会，</em></p><p><em>装了一下午的Linux系统，心态爆炸！！！！不过幸运的是没有放弃，最后终于成功了,在这个过程中同时也学到了很多东西，是之前没有接触到的，有喜有忧，担心还有自己不会的太多了帕跟不上进度，所以阿，杨鑫你一定不能放弃！！坚持到最后，你就是最牛逼的</em></p><hr><h2 id="越努力，越幸运-！-加油"><a href="#越努力，越幸运-！-加油" class="headerlink" title="越努力，越幸运  ！ 加油"></a>越努力，越幸运  ！ 加油</h2>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2019/09/29/hello-world/"/>
      <url>/2019/09/29/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
